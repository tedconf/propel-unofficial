<!--
-File         $Id: FindingObjects.html,v 1.3 2005/02/12 13:05:55 micha Exp $
-License      GNU FDL (http://www.gnu.org/copyleft/fdl.html)
-Copyright    2003, Propel project
-Author       Hans Lellelid, hans@xmpl.org
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/2000/REC-xhtml1-20000126/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Propel Guide</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="Stylesheet" rev="Stylesheet" href="../css/Documentation.css" type="text/css" charset="iso-8859-1"/>
</head>
<body>

<h1>Pobieranie Utrwalonych Obiektów</h1>

<p>Gdy zapiszesz jakiś obiekt w bazie danych, musisz znać sposób na jego późniejsze pozyskanie z bazy. Nauczyłeś się się już pobierać rekordy używając obiektów <strong>Criteria</strong>.  W tym rozdziale przyjrzymy się bliżej innym metodom pozyskiwania obiektów i dokładniej przetestujemy systemy <strong>Criteria</strong> i <strong>Criterion</strong>.</p>

<h2><a name="FindingRecords.byPK"></a>Pobieranie Określonego Rekordu</h2>

<p>Możesz znaleźć określony obiekt (rekord) używając metody <strong>retrieveByPK()</strong> dostępnej w klasie Peer. Jak sama nazwa wskazuje, metoda ta szuka rekordu bazując na dostarczonym - prostym bądź złożonym - kluczu głównym.</p>

<pre title="retrieveByPk() simple key">
// Tabela book posiada pojedynczy klucz główny, którym jest kolumna book_id
// Przyjmnijemy też, że War &amp; Peace (Wojna i Pokój) było pierwszą książką dodaną do tabeli
$warAndPeace = BookPeer::retrieveByPK(1);
</pre>

<p>Oczywiście w wielu przypadkach możesz posiadać tabelę, której klucz główny jest zdefiniowany przez wartości kilku kolumn. Poniżej tabela przedstawiająca relację wiele do wielu:</p>

<pre title="xref schema">
&lt;table name=&quot;book_author_xref&quot; 
      description=&quot;Book-Author Crossreference Table&quot;&gt;
  &lt;column
    name=&quot;book_id&quot;
    required=&quot;true&quot;
    primaryKey=&quot;true&quot;
    type=&quot;INTEGER&quot;
    description=&quot;Book Id&quot;/&gt;
  &lt;column
    name=&quot;author_id&quot;
    required=&quot;true&quot;
    primaryKey=&quot;true&quot;
    type=&quot;INTEGER&quot;
    description=&quot;Author Id&quot;/&gt;
&lt;/table&gt;	
</pre>

<p>W tym przypadku, rekord można pozyskać poprzez przekazanie do metody <strong>retreiveByPK()</strong> tablicy.<strong> Należy przy tym pamiętać,  iż kolejność kluczy w tablicy musi być zgodna z kolejnością kolumn zdefiniowaną w pliku XML.</strong></p>
<pre title="retriveByPK() composite">
// Gets the book_id=1,author_id=2 record
$obj = BookAuthorXrefPeer::retrieveByPK(array(1,2));
</pre>

<h2><a name="FindingRecods.Criteria"></a>Pozyskiwanie Przy Użyciu Obiektu Criteria</h2>

<p><strong>Uwaga: </strong> niekóre z pomysłów i przykładów w tej części pochodzą z HOWTO Criterii dostępnego na stronie <a href="Bibliography.html#bib.torque">Torque</a>.</p>
<p>Aby znaleźć rekordy spełniające określone wymagania, możesz użyć obiektu Criteria w połączeniu z metodą <strong>doSelect()</strong> klasy Peer. To potężny sposób na odnajdywanie rekordów, bo przy pomocy systemu Criteria/Criterion możesz skonstruować niemal każde zapytanie SQL. Metoda <strong>doSelect()</strong> zwraca tablicę obiektów określonego typu.</p>
<pre title="doSelect() example">$c = new Criteria();
$c-&gt;add(AuthorPeer::FIRST_NAME, &quot;Leo&quot;);


$results = AuthorPeer::doSelect($c);
foreach($results as $author) {
  print &quot;Author: &quot; . $author-&gt;getLastName() . &quot;, &quot; . $author-&gt;getFirstName() . &quot;\n&quot;;

} </pre>

<p>Pobieranie rekordów przy użyciu Criteria jest proste nawet dla najbardziej skomplikowanych zapytań. Wymaga jedynie odrobiny praktyki.</p>
<h3>Proste Użycie Criteria</h3>

<p>W najprostszej postaci, system Criteria jest miejscem, w którym kontrolujesz warunki jakie mają spełniać wybierane rekordy:</p>

<pre title="Criteria: simple">
$c = new Criteria();
// Find all authors with first name Karl but
// Znajdz wszytskich autorów  o imieniu Karl, ale
// którzy nie nazywają się Marx.
$c-&gt;add(AuthorPeer::FIRST_NAME, &quot;Karl&quot;);
$c-&gt;add(AuthorPeer::LAST_NAME, &quot;Marx&quot;, Criteria::NOT_EQUAL);

// Znajdź wszytskich autorów, których nazwisko to Tolstoy, Dostoevsky, lub Bakhtin
$c2 = new Criteria();
$c2-&gt;add(AuthorPeer::LAST_NAME, array(&quot;Tolstoy&quot;, &quot;Dostoevsky&quot;, &quot;Bakhtin&quot;), Criteria::IN);

</pre>

<h3>Łączenie Criteria i Criterion</h3>

<p>Nie możesz łaczyć obiektów Criteria ze sobą bezpośrednio, ale możesz łaczyć obiekty Criterion, aby uzyskać logiczne powiązania między nimi.</p>

<pre title="Criteria: combining">
//Znajdź wszystkich autorów o imieniu &quot;Leo&quot; lub nazwisku
// &quot;Tolstoy&quot;, &quot;Dostoevsky&quot;, lub &quot;Bakhtin&quot;
 
$c = new Criteria();
$cton1 = $c-&gt;getNewCriterion(AuthorPeer::FIRST_NAME, "Leo");
$cton2 = $c-&gt;getNewCriterion(AuthorPeer::LAST_NAME, 
                      array(&quot;Tolstoy&quot;, &quot;Dostoevsky&quot;, &quot;Bakhtin&quot;), Criteria::IN);
 
// połącz Criteriony
$cton1-&gt;addOr($cton2);
 
// dodaj do obiektu Criteria
$c-&gt;add($cton1);
</pre>

<h3>Określanie Wielu Warunków dla Kolumny</h3>

<p>W przykładzie powyżej, zobaczyliśmy, jak można określać pojedyncze warunki dla kolumny (np. author.FIRST_NAME = "Leo"). W istocie, określanie wielu warunków dla pojedynczej kolumny jest bardziej złożone, bo Propel przechowuje warunki w tzw. "hashtable" (ze względów wydajnościowych).</p>

<p><strong>Poniżej przykład błędnego użycia Criteria</strong></p>
<pre title="Criteria: WRONG use of multiple conditions">
$c = new Criteria();
$c-&gt;add(AuthorPeer::FIRST_NAME, &quot;Leo%&quot;, Criteria::LIKE);
$c-&gt;add(AuthorPeer::FIRST_NAME, &quot;Leonardo&quot;, Criteria::NOT_EQUAL);
// second add() just overwrote the LIKE condition already in place!
</pre>

<p>Poprawnie, należy zaangażować w to obiekt Criterion. Należy stworzyć obiekt Criterion i wywołać jego metodę - <strong>Criterion::addOr()</strong> aby je powiązać:</p>

<pre title="Criteria: CORRECT use of multiple conditions">
$c = new Criteria();
$criterion = $c-&gt;getNewCriterion(AuthorPeer::FIRST_NAME, &quot;Leo%&quot;, Criteria::LIKE);
$criterion-&gt;addOr($c->getNewCriterion(AuthorPeer::FIRST_NAME, &quot;Leonardo&quot;, Criteria::NOT_EQUAL));

$c->add($criterion);
</pre>


<h3>Kontrolowanie Innych Aspektów Zapytania</h3>

<p>Obiekt Criteria potrafi więcej, niż tylko kontrolować warunki zapytania SQL. Inne aspekty zapytania, które może obsługiwać, to: ilość zwracanych rekordów, rozróżnianie wielkości liter, układanie rekordów w różnej kolejności.</p>

<pre title="">
// Znajdź pierwszych dziesiąciu autorów - alfabetycznie
$c = new Criteria();
$c-&gt;setLimit(10);
$c-&gt;addAscendingOrderByColumn(AuthorPeer::LAST_NAME);

// Znajdź wszystkich autorów o imieniu &quot;max&quot;  - rozróżnij wielkośc liter
$c = new Criteria();
$c-&gt;add(AuthorPeer::FIRST_NAME, &quot;max&quot;);
$c-&gt;setIgnoreCase(true);
</pre>

<p><strong>Uwaga: </strong> Niektóre bazy danych wspierają limitowanie zwracanych rekordów. (np. MySQL i PostgreSQL wspierają klauzulę LIMIT w zapytaniu); W tych przypadkach klasa BasePeer użyje natywnego limitowania, podczas gdy w innych będzie emulowała wsparcie dla LIMIT (poprzez pobranie normalnego zestawu rekordów, a następnie zwrócenie tylko tych określonych przez LIMIT).</p>

<h3>Zaawansowane Możliwości Criteria</h3>

<p>Obiekt Criteria przychodzi z pomocą nawet wtedy, gdy chcesz napisać kod, który zwróci surowy (bez inicjowania obiektów) wynik zapytania. Np. jeśli potrzebujesz bardzo wydajnego kodu, który zwróci listę wszystkich numerów ISBN z bazy danych wg. pewnych kryteriów.</p>

<pre title="Specyfing select columns in criteria">
class BookPeer extends BaseBookPeer {
  .
  .
  .
  /**
   * Pobierz tylko numery ISBN książek
   * @param Criteria $c kryteria filtrowania
   * @return array Tablica numerów ISBN
   */
  function getJustISBN(Criteria $c) {
    $c-&gt;clearSelectColumns()-&gt;addSelectColumn(self::ISBN);
    $rs = BasePeer::doSelectRS($c);
    $isbns = array();
    while($rs-&gt;next()) {
      $isbns[] = $rs-&gt;get(1);
    }
    return $isbns;
  }
</pre>
<h2><a name="WritingSQL"></a>Pobieranie Rekordów z Użyciem SQL</h2>
<p>Klasa Criteria jest w stanie &quot;skompilować&quot; najczęściej używane zapytania SQL, ale na pewno nie każde. W przypadku, gdy musisz wykonać szczególnie złożone zapytanie, będziesz musiał sam napisać kod SQL. Najlepiej w odpowiedniej klasie dziedziczącej po Base*Peer. Aby się upewnić, żę zapytanie wykona się nawet, gdy zmianie ulegną nazwy kolumn, możesz użyć stałych <strong>Peer::COLUMN_NAME</strong> i <strong>Peer::TABLENAME</strong>.</p>
<pre title="Writing SQL example">
class BookPeer extends BaseBookPeer {
  .
  .
  .
  /**
   * Pobierz tylko książki, które nie zostały sprawdzone
   * @return array Book[]
   */
  function getUnreviewedBooks() {
    $con = Propel::getConnection(DATABASE_NAME);

    // jeśli używasz sterownka, który nie obsługuje podzapytań
    // musisz wykonać join (left join)
    $sql = "SELECT books.* FROM books WHERE ".
           "NOT EXISTS (SELECT id FROM review WHERE book_id = book.id)";
    
    $stmt = $con->createStatement();
    $rs = $stmt->executeQuery($sql, ResultSet::FETCHMODE_NUM);
    
    return parent::populateObjects($rs);	
  }</pre>
<p><em>Uwaga: w powyższym przykładzie zakładamy, że kolumny w tabeli są zdefiniowane tak samo jak w pliku XML. Zazwyczaj tak jest, jeśli nie modyfikowałeś tabeli. Aby jednak usunąć i tą zależność, możesz użyć metod <strong>Peer::addSelectColumns(Criteria)</strong> 
  i<strong> Criteria-&gt;getSelectColumns()</strong></em></p>
<p>W naszym przykładzie nie użyliśmy zdefiniowanych stałych dla kolumn (aby uprościć przykład), ale możesz to łatwo wykonać, wstawiając je w powyższe zapytanie SQL. Unikniesz potrzeby zmieniania tego zapytania, gdy zmienisz nazwę kolumny lub tabeli:</p>
<pre title="SQL example using constants">$sql = &quot;SELECT b.* FROM &quot;.BookPeer::TABLE_NAME.&quot; b WHERE &quot;.
       &quot;NOT EXISTS (SELECT r.&quot;.ReviewPeer::ID.&quot; FROM &quot;.ReviewPeer::TABLE_NAME.&quot; r &quot;.
       &quot;            WHERE r.&quot;.ReviewPeer::BOOK_ID.&quot; = b.&quot;.BookPeer::ID.&quot;)&quot;;</pre>
<p>Oczywiście to Twoja decyzja, czy opłaca się osiagnąć większą elastycznośc zapytania kosztem jego czytelności. Zrób jak uważasz.</p>
<h2><a name="PopulatingSingleObjects"></a>Pobieranie Dużych Porcji Danych</h2>
<p>W niektórych przypadkach nie bedziesz chciał, aby Peer tworzył wszystkie obiekty i zwracał ich tablicę. Szczególnie, pobieranie dużych porcji danych może stworzyć problemy z pamięcią (w PHP), gdy każesz zwrócić taką tablicę obiektów. Aby obejść ten problem możesz przeglądać (iterować) wyniki i pobierać pojedyncze obiekty przy użyciu metody <strong>Entity-&gt;hydrate() </strong> i pozbywać się ich, gdy nie są Ci już potrzebne.</p>
<pre title="populate single object">// Pobierz listę książek (udawajmy że jest ich dużo)
$rs = BookPeer::doSelectRS(new Criteria());
while($rs-&gt;next()) { // Użyj metody Creole ResultSet aby przeiterować przez wyniki
  $book = new Book();
  $book-&gt;hydrate($rs);
  
  // czytaj wartości $book , zapisz $book, itp..
  ...
}</pre>
<p>Oczywiście działa to niezależnie od tego, czy używasz Criteria do wykonania zapytań, czy zwykłych zapytań SQL. Najważniejszą rzeczą do zapamiętania jest fakt, że rekordy są pobierane z bazy dopiero gdy są potrzebne. Obiekty też są tworzone dopiero na życzenie.</p>
</body>
</html>

<?php

/*
 *  $Id: PHP5BasicObjectBuilder.php 157 2005-08-10 19:16:22Z hans $
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * This software consists of voluntary contributions made by many individuals
 * and is licensed under the LGPL. For more information please see
 * <http://propel.phpdb.org>.
 */

require_once 'propel/engine/builder/om/PeerBuilder.php';

/**
 * Generates a PHP5 tree nested set Peer class for user object model (OM).
 *
 * This class produces the base tree nested set object class (e.g. BaseMyTable) which contains all
 * the custom-built accessor and setter methods.
 *
 * This class replaces the Node.tpl, with the intent of being easier for users
 * to customize (through extending & overriding).
 *
 * @author heltem <heltem@o2php.com>
 * @package propel.engine.builder.om.php5
 */
class PHP5NestedSetPeerBuilder extends PeerBuilder {

	/**
	 * Gets the package for the [base] object classes.
	 * @return string
	 */
	public function getPackage()
	{
		return parent::getPackage() . ".om";
	}

	/**
	 * Returns the name of the current class being built.
	 * @return string
	 */
	public function getUnprefixedClassname()
	{
		return $this->getBuildProperty('basePrefix') . $this->getStubObjectBuilder()->getClassname() . 'NestedSetPeer';
	}

	/**
	 * Adds the include() statements for files that this class depends on or utilizes.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addIncludes(&$script)
	{
		$script .="
require '".$this->getPeerBuilder()->getClassFilePath()."';
";
	} // addIncludes()

	/**
	 * Adds class phpdoc comment and openning of class.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addClassOpen(&$script)
	{

		$table = $this->getTable();
		$tableName = $table->getName();
		$tableDesc = $table->getDescription();

		$script .= "
/**
 * Base static class for performing query operations on the tree contained by the '$tableName' table.
 *
 * $tableDesc
 *";
		if ($this->getBuildProperty('addTimeStamp')) {
			$now = strftime('%c');
			$script .= "
 * This class was autogenerated by Propel " . $this->getBuildProperty('version') . " on:
 *
 * $now
 *";
		}
		$script .= "
 * @package ".$this->getPackage()."
 */
abstract class ".$this->getClassname()." extends ".$this->getPeerBuilder()->getClassName()." implements BaseNodePeer {
";
	}

	/**
	 * Specifies the methods that are added as part of the basic OM class.
	 * This can be overridden by subclasses that wish to add more methods.
	 * @see ObjectBuilder::addClassBody()
	 */
	protected function addClassBody(&$script)
	{
		$table = $this->getTable();

		// FIXME
		// - Probably the build needs to be customized for supporting
		// tables that are "aliases".  -- definitely a fringe usecase, though.

		$this->addConstants($script);

		$this->addCreateRoot($script);

		$this->addRetrieveRoot($script);

		$this->addInsertAsFirstChildOf($script);
		$this->addInsertAsLastChildOf($script);
		$this->addInsertAsPrevSiblingOf($script);
		$this->addInsertAsNextSiblingOf($script);

		$this->addInsertRoot($script);
		$this->addInsertParent($script);

		$this->addDeleteRoot($script);
		$this->addDeleteNode($script);

		$this->addMoveToFirstChildOf($script);
		$this->addMoveToLastChildOf($script);
		$this->addMoveToPrevSiblingOf($script);
		$this->addMoveToNextSiblingOf($script);

		$this->addRetrieveFirstChild($script);
		$this->addRetrieveLastChild($script);
		$this->addRetrievePrevSibling($script);
		$this->addRetrieveNextSibling($script);

		$this->addRetrieveTree($script);
		$this->addRetrieveBranch($script);
		$this->addRetrieveChildren($script);
		$this->addRetrieveDescendants($script);
		$this->addRetrieveSiblings($script);
		$this->addRetrieveParent($script);
		$this->addRetrieveUndefined($script);

		$this->addGetLevel($script);
		$this->addGetNumberOfChildren($script);
		$this->addGetNumberOfDescendants($script);
		$this->addGetPath($script);

		$this->addIsValid($script);
		$this->addIsRoot($script);
		$this->addIsLeaf($script);
		$this->addIsChildOf($script);
		$this->addIsChildOfOrSiblingTo($script);
		$this->addIsEqualTo($script);

		$this->addHasParent($script);
		$this->addHasPrevSibling($script);
		$this->addHasNextSibling($script);
		$this->addHasChildren($script);

		$this->addDeleteDescendants($script);

		$this->addGetNode($script);

		$this->addHydrateDescendants($script);
		$this->addHydrateChildren($script);

		$this->addInsertNode($script);
		$this->addUpdateNode($script);

		$this->addShiftRLValues($script);
		$this->addShiftRLRange($script);
	}

	/**
	 * Closes class.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addClassClose(&$script)
	{
		$script .= "
} // " . $this->getClassname() . "
";
	}

	protected function addConstants(&$script)
	{
		$table = $this->getTable();
		$tableName = $table->getName();

		$left_colname = '';
		$right_colname = '';

		foreach ($table->getColumns() as $col) {
			if ($col->isNestedSetLeftKey()) {
				$left_colname = $tableName . '.' . strtoupper($col->getName());
			}

			if ($col->isNestedSetRightKey()) {
				$right_colname = $tableName . '.' . strtoupper($col->getName());
			}

 			if (!empty($right_name) && !empty($left_colname)) {
 			    break;
 			}
		}
		$script .= "
	/**
	 * Left column for the set
	 */
	const LEFT_COL = '$left_colname';

	/**
	 * Right column for the set
	 */
	const RIGHT_COL = '$right_colname';
";
	}

	protected function addCreateRoot(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$objectClassname = $this->getStubObjectBuilder()->getClassname();
		$script .= "
	/**
	 * Creates the supplied node as the root node.
	 *
	 * @param $objectClassname \$node	Propel object for model
	 * @param PDO \$con      Connection to use.
	 * @return $objectClassname		Inserted propel object for model
	 * @throws PropelException
	 */
	static function createRoot(\$node, PDO \$con = null)
	{
		if (\$con === null) {
			\$con = Propel::getConnection($peerClassname::DATABASE_NAME);
		}

		\$newLeft = 1;
		\$newRight = 2;
		return self::insertNode(\$node, \$newLeft, \$newRight, \$con);
	}
";
	}

	protected function addRetrieveRoot(&$script)
	{
		$objectClassname = $this->getStubObjectBuilder()->getClassname();
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Returns the root node for a given root id
	 *
	 * @param int \$rootId		Root id to determine which root node to return
	 * @param PDO \$con      Connection to use.
	 * @return $objectClassname			Propel object for root node
	 */
	static function retrieveRoot(\$rootId = 1, PDO \$con = null)
	{
		\$c = new Criteria($peerClassname::DATABASE_NAME);
		\$c->add(self::LEFT_COL, \$rootId, Criteria::EQUAL);

		return $peerClassname::doSelectOne(\$c, \$con);
	}
";
	}

	protected function addInsertAsFirstChildOf(&$script)
	{
		$objectClassname = $this->getStubObjectBuilder()->getClassname();
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Inserts \$child as first child of destination node \$parent
	 *
	 * @param $objectClassname \$parent	Propel object for parent node
	 * @param $objectClassname \$child	Propel object for child node
	 * @param PDO \$con      Connection to use.
	 * @return object		Inserted propel object for model
	 */
	static function insertAsFirstChildOf(\$parent, \$child, PDO \$con = null)
	{
		if (!\$parent = $peerClassname::getNode(\$parent, \$con)) {
			return false;
		}

		\$newLeft = \$parent->getLeftValue() + 1;
		\$newRight = \$parent->getLeftValue() + 2;
		self::shiftRLValues(\$newLeft, 2, \$con);
		\$parent->setRightValue(\$parent->getRightValue() + 2);
		return self::insertNode(\$child, \$newLeft, \$newRight, \$con);
	}
";
	}

	protected function addInsertAsLastChildOf(&$script)
	{
		$objectClassname = $this->getStubObjectBuilder()->getClassname();
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Inserts \$child as last child of destination node \$parent
	 *
	 * @param $objectClassname \$parent	Propel object for parent node
	 * @param $objectClassname \$child	Propel object for child node
	 * @param PDO \$con      Connection to use.
	 * @return object		Inserted propel object for model
	 */
	static function insertAsLastChildOf(\$parent, \$child, PDO \$con = null)
	{
		if (!\$parent = $peerClassname::getNode(\$parent, \$con)) {
			return false;
		}

		\$newLeft = \$parent->getRightValue();
		\$newRight = \$parent->getRightValue() + 1;
		self::shiftRLValues(\$newLeft, 2, \$con);
		\$parent->setRightValue(\$parent->getRightValue() + 2);
		return self::insertNode(\$child, \$newLeft, \$newRight, \$con);
	}
";
	}

	protected function addInsertAsPrevSiblingOf(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Inserts \$node as previous sibling to destination node \$dest
	 *
	 * @param object \$dest	Propel object for destination node
	 * @param object \$node	Propel object for source node
	 * @param PDO \$con      Connection to use.
	 * @return object		Inserted propel object for model
	 */
	static function insertAsPrevSiblingOf(\$dest, \$node, PDO \$con = null)
	{
		\$dest = $peerClassname::getNode(\$dest, \$con);

		\$newLeft = \$dest->getLeftValue();
		\$newRight = \$dest->getLeftValue() + 1;
		self::shiftRLValues(\$newLeft, 2, \$con);
		\$dest->setLeftValue(\$dest->getLeftValue() + 2);
		\$dest->setRightValue(\$dest->getRightValue() + 2);
		return self::insertNode(\$node, \$newLeft, \$newRight, \$con);
	}
";
	}

	protected function addInsertAsNextSiblingOf(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Inserts \$node as next sibling to destination node \$dest
	 *
	 * @param object \$dest	Propel object for destination node
	 * @param object \$node	Propel object for source node
	 * @param PDO \$con      Connection to use.
	 * @return object		Inserted propel object for model
	 */
	static function insertAsNextSiblingOf(\$dest, \$node, PDO \$con = null)
	{
		\$dest = $peerClassname::getNode(\$dest, \$con);

		\$newLeft = \$dest->getRightValue() + 1;
		\$newRight = \$dest->getRightValue() + 2;
		self::shiftRLValues(\$newLeft, 2, \$con);
		return self::insertNode(\$node, \$newLeft, \$newRight, \$con);
	}
";
	}

	protected function addInsertRoot(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Inserts \$node as root node
	 *
	 * @param object \$node	Propel object as root node
	 * @param PDO \$con      Connection to use.
	 * @return object		Inserted propel object for model
	 */
	static function insertRoot(\$node, PDO \$con = null)
	{
		return $peerClassname::insertParent($peerClassname::retrieveRoot(\$con), \$node, \$con = null);
	}
";
	}

	protected function addInsertParent(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Inserts \$node as parent to destination node \$dest
	 *
	 * @param object \$dest	Propel object to become child node
	 * @param object \$node	Propel object as root node
	 * @param PDO \$con      Connection to use.
	 * @return object		Inserted propel object for model
	 */
	static function insertParent(\$dest, \$node, PDO \$con = null)
	{
		\$dest = $peerClassname::getNode(\$dest, \$con);

		self::shiftRLValues(\$dest->getLeftValue(), 1, \$con);
		self::shiftRLValues(\$dest->getRightValue() + 2, 1, \$con);

		\$newLeft = \$dest->getLeftValue();
		\$newRight = \$dest->getRightValue() + 2;
		return self::insertNode(\$node, \$newLeft, \$newRight, \$con);
	}
";
	}

	protected function addDeleteRoot(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Delete root node
	 *
	 * @param PDO \$con      Connection to use.
	 * @return boolean		Deletion status
	 */
	static function deleteRoot(PDO \$con = null)
	{
		\$root = $peerClassname::retrieveRoot(\$con);
		if ($peerClassname::getNumberOfChildren(\$root) == 1) {
			return $peerClassname::deleteNode(\$root, \$con);
		} else {
			return false;
		}
	}
";
	}

	protected function addDeleteNode(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Delete \$dest node
	 *
	 * @param object \$dest	Propel object node to delete
	 * @param PDO \$con      Connection to use.
	 * @return boolean		Deletion status
	 */
	static function deleteNode(\$dest, PDO \$con = null)
	{
		\$dest = $peerClassname::getNode(\$dest, \$con);

		if (\$dest->getLeftValue() == 1) {
			return $peerClassname::deleteRoot(\$con); // deleting root implies conditions (see deleteRoot() method)
  		}

		self::shiftRLRange(\$dest->getLeftValue(), \$dest->getRightValue(), -1, \$con);
		self::shiftRLValues(\$dest->getRightValue() + 1, -2, \$con);
		return \$dest->delete(false, \$con);
	}
";
	}

	protected function addMoveToFirstChildOf(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Moves \$node to be first child of \$destNode
	 *
	 * @param object \$destNode	Propel object for destination node
	 * @param object \$node		Propel object for source node
	 * @param PDO \$con      Connection to use.
	 */
	static function moveToFirstChildOf(\$dest, \$node, PDO \$con = null)
	{
		\$dest = $peerClassname::getNode(\$dest);

		\$destLeft = \$dest->getLeftValue();
		\$destLeft = \$destLeft + 1;
		self::updateNode(\$node, \$destLeft, \$con);
	}
";
	}

	protected function addMoveToLastChildOf(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Moves \$node to be last child of \$destNode
	 *
	 * @param object \$destNode	Propel object for destination node
	 * @param object \$node		Propel object for source node
	 * @param PDO \$con      Connection to use.
	 */
	static function moveToLastChildOf(\$dest, \$node, PDO \$con = null)
	{
		\$dest = $peerClassname::getNode(\$dest, \$con);

		\$destLeft = \$dest->getRightValue();
		self::updateNode(\$node, \$destLeft, \$con);
	}
";
	}

	protected function addMoveToPrevSiblingOf(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Moves \$node to be prev sibling to \$destNode
	 *
	 * @param object \$destNode	Propel object for destination node
	 * @param object \$node		Propel object for source node
	 * @param PDO \$con      Connection to use.
	 */
	static function moveToPrevSiblingOf(\$dest, \$node, PDO \$con = null)
	{
		\$dest = $peerClassname::getNode(\$dest, \$con);

		\$destLeft = \$dest->getLeftValue();
		self::updateNode(\$node, \$destLeft, \$con);
	}
";
	}

	protected function addMoveToNextSiblingOf(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Moves \$node to be next sibling to \$destNode
	 *
	 * @param object \$destNode	Propel object for destination node
	 * @param object \$node		Propel object for source node
	 * @param PDO \$con      Connection to use.
	 */
	static function moveToNextSiblingOf(\$dest, \$node, PDO \$con = null)
	{
		\$dest = $peerClassname::getNode(\$dest, \$con);

		\$destLeft = \$dest->getRightValue();
		\$destLeft = \$destLeft + 1;
		self::updateNode(\$node, \$destLeft, \$con);
	}
";
	}

	protected function addRetrieveFirstChild(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Gets first child for the given node if it exists
	 *
	 * @param object \$node	Propel object for src node
	 * @param PDO \$con      Connection to use.
	 * @return mixed 		Propel object if exists else false
	 */
	static function retrieveFirstChild(\$node, PDO \$con = null)
	{
		\$node = $peerClassname::getNode(\$node, \$con);

		\$c = new Criteria();
		\$c->add(self::LEFT_COL, \$node->getLeftValue() + 1, Criteria::EQUAL);

		return $peerClassname::doSelectOne(\$c, \$con);
	}
";
	}

	protected function addRetrieveLastChild(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Gets last child for the given node if it exists
	 *
	 * @param object \$node	Propel object for src node
	 * @param PDO \$con      Connection to use.
	 * @return mixed 		Propel object if exists else false
	 */
	static function retrieveLastChild(\$node, PDO \$con = null)
	{
		\$node = $peerClassname::getNode(\$node, \$con);

		\$c = new Criteria();
		\$c->add(self::RIGHT_COL, \$node->getRightValue() - 1, Criteria::EQUAL);

		return $peerClassname::doSelectOne(\$c, \$con);
	}
";
	}

	protected function addRetrievePrevSibling(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Gets prev sibling for the given node if it exists
	 *
	 * @param object \$node	Propel object for src node
	 * @param PDO \$con      Connection to use.
	 * @return mixed 		Propel object if exists else false
	 */
	static function retrievePrevSibling(\$node, PDO \$con = null)
	{
		\$node = $peerClassname::getNode(\$node, \$con);

		\$c = new Criteria();
		\$c->add(self::RIGHT_COL, \$node->getLeftValue() - 1, Criteria::EQUAL);

		return $peerClassname::doSelectOne(\$c, \$con);
	}
";
	}

	protected function addRetrieveNextSibling(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Gets next sibling for the given node if it exists
	 *
	 * @param object \$node	Propel object for src node
	 * @param PDO \$con      Connection to use.
	 * @return mixed 		Propel object if exists else false
	 */
	static function retrieveNextSibling(\$node, PDO \$con = null)
	{
		\$node = $peerClassname::getNode(\$node, \$con);

		\$c = new Criteria();
		\$c->add(self::LEFT_COL, \$node->getRightValue() + 1, Criteria::EQUAL);

		return self::doSelectOne(\$c, \$con);
	}
";
	}

	protected function addRetrieveTree(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$objectName = $this->getStubObjectBuilder()->getClassname();
		$script .= "
	/**
	 * Retrieves the entire tree from root
	 *
	 * @param PDO \$con      Connection to use.
	 */
	static function retrieveTree(PDO \$con = null)
	{
		\$c = new Criteria();
		\$c->addAscendingOrderByColumn(self::LEFT_COL);
		\$stmt = $peerClassname::doSelectStmt(\$c, \$con);
		if (false !== (\$row = \$stmt->fetch())) {
			\$root = new $objectName();
			\$root->hydrate(\$row);
			\$root->setLevel(0);
			self::hydrateDescendants(\$root, \$stmt);

			return \$root;
  		}
  		return false;
	}
";
	}

	protected function addRetrieveBranch(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Retrieves the entire tree from root
	 *
	 * @param PDO \$con      Connection to use.
	 */
	static function retrieveBranch(\$node, PDO \$con = null)
	{
		return $peerClassname::retrieveDescendants(\$node, \$con);
	}
";
	}

	protected function addRetrieveChildren(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Gets direct children for the node
	 *
	 * @param PDO \$con      Connection to use.
	 */
	static function retrieveChildren(\$node, PDO \$con = null)
	{
		if (is_array(\$node->_children)) {
			return \$node->_children;
		}

		\$c = new Criteria();
		\$c->addAscendingOrderByColumn(self::LEFT_COL);
		\$c->add(self::LEFT_COL, \$node->getLeftValue(), Criteria::GREATER_THAN);
		\$c->addAnd(self::RIGHT_COL, \$node->getRightValue(), Criteria::LESS_THAN);
		\$stmt = $peerClassname::doSelectStmt(\$c, \$con);

		self::hydrateChildren(\$node, \$stmt);
		return \$node->_children;
	}
";
	}

	protected function addRetrieveDescendants(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Gets all descendants for the node
	 *
	 * @param PDO \$con      Connection to use.
	 */
	static function retrieveDescendants(\$node, PDO \$con = null)
	{
		if (is_array(\$node->_children)) {
			return \$node->_children;
		}

		\$c = new Criteria();
		\$c->addAscendingOrderByColumn(self::LEFT_COL);
		\$c->add(self::LEFT_COL, \$node->getLeftValue(), Criteria::GREATER_THAN);
		\$c->addAnd(self::RIGHT_COL, \$node->getRightValue(), Criteria::LESS_THAN);
		\$stmt = $peerClassname::doSelectStmt(\$c, \$con);

		self::hydrateDescendants(\$node, \$stmt);
		return \$node->_children;
	}
";
	}

	protected function addRetrieveSiblings(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Gets all siblings for the node
	 *
	 * @param PDO \$con      Connection to use.
	 */
	static function retrieveSiblings(\$node, \$selectMethod = 'doSelectStmt', PDO \$con = null)
	{
		\$parent = $peerClassname::retrieveParent(\$node, \$con);
		\$siblings = $peerClassname::retrieveChildren(\$parent, \$con);

		return \$siblings;
	}
";
	}

	protected function addRetrieveParent(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Gets ancestor for the given node if it exists
	 *
	 * @param object \$node	Propel object for src node
	 * @param PDO \$con      Connection to use.
	 * @return mixed 		Propel object if exists else false
	 */
	static function retrieveParent(\$node, PDO \$con = null)
	{
		\$node = self::getNode(\$node);

		\$c = new Criteria();
		\$c1 = \$c->getNewCriterion(self::LEFT_COL, \$node->getLeftValue(), Criteria::LESS_THAN);
		\$c2 = \$c->getNewCriterion(self::RIGHT_COL, \$node->getRightValue(), Criteria::GREATER_THAN);

		\$c1->addAnd(\$c2);

		\$c->add(\$c1);
		\$c->addAscendingOrderByColumn(self::RIGHT_COL);

		\$results = $peerClassname::doSelect(\$c, \$con);

		return array_shift(\$results);
	}
";
	}

	protected function addRetrieveUndefined(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Gets ancestor for the given node if it exists
	 *
	 * @param object \$node	Propel object for src node
	 * @param PDO \$con      Connection to use.
	 * @return mixed 		Propel object if exists else false
	 */
	static function retrieveUndefined(PDO \$con = null)
	{
		\$c = new Criteria();
		\$c1 = \$c->getNewCriterion(self::LEFT_COL, 0);
		\$c2 = \$c->getNewCriterion(self::RIGHT_COL, 0);

		\$c1->addAnd(\$c2);

		\$c->add(\$c1);

		\$results = $peerClassname::doSelect(\$c, \$con);

		return \$results;
	}
";
	}

	protected function addGetLevel(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Gets level for the given node
	 *
	 * @param object \$node	Propel object for src node
	 * @param PDO \$con      Connection to use.
	 * @return int			Level for the given node
	 */
	static function getLevel(\$node, PDO \$con = null)
	{
		\$node = $peerClassname::getNode(\$node, \$con);

		if (\$con === null) {
			\$con = Propel::getConnection($peerClassname::DATABASE_NAME);
		}

		\$sql = \"SELECT COUNT(*) AS level FROM \" . self::TABLE_NAME . \" WHERE \" . self::LEFT_COL . \" < ? AND \" . self::RIGHT_COL . \" > ?\";
		\$stmt = \$con->prepare(\$sql);
		\$stmt->bindParam(1, \$node->getLeftValue(), PDO::PARAM_INT);
		\$stmt->bindParam(2, \$node->getRightValue(), PDO::PARAM_INT);
		\$stmt->execute();
		\$row = \$stmt->fetch();
		return \$row['level'];
	}
";
	}

	protected function addGetNumberOfChildren(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Gets number of direct children for given node
	 *
	 * @param object \$node	Propel object for src node
	 * @param PDO \$con      Connection to use.
	 * @return int			Level for the given node
	 */
	static function getNumberOfChildren(\$node, PDO \$con = null)
	{
		\$children = $peerClassname::retrieveChildren(\$node);
		return count(\$children);
	}
";
	}

	protected function addGetNumberOfDescendants(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Gets number of descendants for given node
	 *
	 * @param object \$node	Propel object for src node
	 * @param PDO \$con      Connection to use.
	 * @return int			Level for the given node
	 */
	static function getNumberOfDescendants(\$node, PDO \$con = null)
	{
		\$node = $peerClassname::getNode(\$node, \$con);

		\$right = \$node->getRightValue();
		\$left = \$node->getLeftValue();
		\$num = (\$right - \$left - 1) / 2;
		return \$num;
	}
";
	}

	protected function addGetPath(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
 	/**
	 * Returns path to a specific node as an array, useful to create breadcrumbs
	 *
	 * @param object \$node		Propel object of node to create path to
	 * @param PDO \$con      Connection to use.
	 * @return array			Array in order of heirarchy
	 */
	static function getPath(\$node, PDO \$con = null)
	{
		\$node = $peerClassname::getNode(\$node, \$con);

		\$path = array();
		\$path[] = \$node;

		while(\$parent = $peerClassname::retrieveParent(\$node, \$con))
		{
			\$path[] = \$parent;
			\$node = \$parent;
		}

		return array_reverse(\$path);
	}
";
	}

	protected function addIsValid(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Tests if node is valid
	 *
	 * @param object \$node	Propel object for src node
	 * @param PDO \$con      Connection to use.
	 * @return bool
	 */
	static function isValid(\$node, PDO \$con = null)
	{
		\$node = $peerClassname::getNode(\$node, \$con);

		if (is_object(\$node) && \$node->getRightValue() > \$node->getLeftValue()) {
			return true;
		} else {
			return false;
		}
	}
";
	}

	protected function addIsRoot(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Tests if node is a root
	 *
	 * @param object \$node	Propel object for src node
	 * @param PDO \$con      Connection to use.
	 * @return bool
	 */
	static function isRoot(\$node, PDO \$con = null)
	{
		\$node = $peerClassname::getNode(\$node, \$con);
		return (\$node->getLeftValue()==1);
	}
";
	}

	protected function addisLeaf(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Tests if node is a leaf
	 *
	 * @param object \$node	Propel object for src node
	 * @param PDO \$con      Connection to use.
	 * @return bool
	 */
	static function isLeaf(\$node, PDO \$con = null)
	{
		\$node = $peerClassname::getNode(\$node, \$con);
		return ((\$node->getRightValue()-\$node->getLeftValue())==1);
	}
";
	}

	protected function addisChildOf(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Tests if \$node1 is a child of \$node2
	 *
	 * @param object \$node1		Propel object for node
	 * @param object \$node2		Propel object for node
	 * @param PDO \$con      Connection to use.
	 * @return bool
	 */
	static function isChildOf(\$node2, \$node1, PDO \$con = null)
	{
		\$node1 = $peerClassname::getNode(\$node1, \$con);
		\$node2 = $peerClassname::getNode(\$node2, \$con);

		return ((\$node1->getLeftValue()>\$node2->getLeftValue()) and (\$node1->getRightValue()<\$node2->getRightValue()));
	}
";
	}

	protected function addIsChildOfOrSiblingTo(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Tests if \$node1 is a child of or equal to \$node2
	 *
	 * @param object \$node1		Propel object for node
	 * @param object \$node2		Propel object for node
	 * @param PDO \$con      Connection to use.
	 * @return bool
	 */
	static function isChildOfOrSiblingTo(\$node2, \$node1, PDO \$con = null)
	{
		\$node1 = $peerClassname::getNode(\$node1, \$con);
		\$node2 = $peerClassname::getNode(\$node2, \$con);

		return ((\$node1->getLeftValue()>=\$node2->getLeftValue()) and (\$node1->getRightValue()<=\$node2->getRightValue()));
	}
";
	}

	protected function addIsEqualTo(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Tests if \$node1 is equal to \$node2
	 *
	 * @param object \$node1		Propel object for node
	 * @param object \$node2		Propel object for node
	 * @param PDO \$con      Connection to use.
	 * @return bool
	 */
	static function isEqualTo(\$node1, \$node2, PDO \$con = null)
	{
		\$node1 = $peerClassname::getNode(\$node1, \$con);
		\$node2 = $peerClassname::getNode(\$node2, \$con);

		return ((\$node1->getLeftValue() == \$node2->getLeftValue()) and (\$node1->getRightValue() == \$node2->getRightValue()));
	}
";
	}

	protected function addHasParent(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Tests if \$node has an ancestor
	 *
	 * @param object \$node		Propel object for node
	 * @param PDO \$con      Connection to use.
	 * @return bool
	 */
	static function hasParent(\$node, PDO \$con = null)
	{
		\$node = $peerClassname::getNode(\$node, \$con);
		return $peerClassname::isValid($peerClassname::retrieveParent(\$node, \$con), \$con);
	}
";
	}

	protected function addHasPrevSibling(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Tests if \$node has prev sibling
	 *
	 * @param object \$node		Propel object for node
	 * @param PDO \$con      Connection to use.
	 * @return bool
	 */
	static function hasPrevSibling(\$node, PDO \$con = null)
	{
		\$node = $peerClassname::getNode(\$node, \$con);
		return $peerClassname::isValid($peerClassname::retrievePrevSibling(\$node, \$con), \$con);
	}
";
	}

	protected function addHasNextSibling(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Tests if \$node has next sibling
	 *
	 * @param object \$node		Propel object for node
	 * @param PDO \$con      Connection to use.
	 * @return bool
	 */
	static function hasNextSibling(\$node, PDO \$con = null)
	{
		\$node = $peerClassname::getNode(\$node, \$con);
		return $peerClassname::isValid($peerClassname::retrieveNextSibling(\$node, \$con), \$con);
	}
";
	}

	protected function addHasChildren(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Tests if \$node has children
	 *
	 * @param object \$node		Propel object for node
	 * @param PDO \$con      Connection to use.
	 * @return bool
	 */
	static function hasChildren(\$node, PDO \$con = null)
	{
		\$node = $peerClassname::getNode(\$node, \$con);
		return ((\$node->getRightValue()-\$node->getLeftValue())>1);
	}
";
	}

	protected function addDeleteDescendants(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Deletes \$node and all of its descendants
	 *
	 * @param object \$node		Propel object for source node
	 * @param PDO \$con      Connection to use.
	 */
	static function deleteDescendants(\$node, PDO \$con = null)
	{
		\$node = $peerClassname::getNode(\$node, \$con);

		\$c = new Criteria();
		\$c1 = \$c->getNewCriterion(self::LEFT_COL, \$node->getLeftValue(), Criteria::GREATER_THAN);
		\$c2 = \$c->getNewCriterion(self::RIGHT_COL, \$node->getRightValue(), Criteria::LESS_THAN);

		\$c1->addAnd(\$c2);

		\$c->add(\$c1);
		\$c->addAscendingOrderByColumn(self::RIGHT_COL);

		\$result = $peerClassname::doDelete(\$c, \$con);

		self::shiftRLValues(\$right + 1, \$left - \$right -1, \$con);

		return \$result;
	}
";
	}

	protected function addGetNode(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Returns a node given its primary key or the node itself
	 *
	 * @param int \$node	Primary key of required node
	 * @param PDO \$con      Connection to use.
	 * @return object		Propel object for model
	 */
	static function getNode(\$node, PDO \$con = null)
	{
		if (is_object(\$node)) {
			return \$node;
		} else {
			\$object = $peerClassname::retrieveByPK(\$node, \$con);
			\$rtn = is_object(\$object) ? \$object : false;
			return \$rtn;
		}
	}
";
	}

	protected function addHydrateDescendants(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$objectName = $this->getStubObjectBuilder()->getClassname();
		$script .= "
	/**
	 * Hydrate recursively the descendants of the given node
	 * @param object \$node	Propel object for src node
	 * @param PDOStatement \$stmt	Executed PDOStatement
	 */
	protected static function hydrateDescendants(\$node, PDOStatement \$stmt)
	{
		\$node->_children = array();
		while(\$row = \$stmt->fetch()) {
			\$child = new $objectName();
			\$child->hydrate(\$row);
			\$child->setLevel(\$node->getLevel() + 1);

			if (\$child->hasChildren()) {
				$peerClassname::hydrateDescendants(\$child, \$stmt);
			}

			\$node->_children[] = \$child;

			if (\$child->getRightValue() + 1 == \$node->getRightValue()) {
				break;
			}
		}
	}
";
	}

	protected function addHydrateChildren(&$script)
	{
		$objectName = $this->getStubObjectBuilder()->getClassname();
		$script .= "
	/**
	 * Hydrate the children of the given node
	 * @param object \$node Propel object for src node
	 * @param PDOStatement \$stmt Executed PDOStatement
	 */
	protected static function hydrateChildren(\$node, PDOStatement \$stmt)
	{
		\$node->_children = array();
		while(\$row = \$stmt->fetch()) {
			\$child = new $objectName();
			\$child->hydrate(\$row);
			\$child->setLevel(\$node->getLevel() + 1);

			\$node->_children[] = \$child;

			if (\$child->getRightValue() + 1 == \$node->getRightValue()) {
				break;
			}
		}
	}
";
	}

	protected function addInsertNode(&$script)
	{
		$script .= "
	/**
	 * Inserts a node with given Left and Right values and to the appropriate root
	 *
	 * @param object \$node		Propel object for model
	 * @param int \$left			Left Value
	 * @param int \$right		Right Value
	 * @param int \$right		Root Id
	 * @param PDO \$con      Connection to use.
	 * @return object			Inserted propel object for model
	 */
	protected static function insertNode(\$node, \$left, \$right, PDO \$con = null)
	{
		if (!is_object(\$node)) {
			return false;
		}

		\$node->setLeftValue(\$left);
		\$node->setRightValue(\$right);
		\$node->save(\$con);
		return \$node;
	}
";
	}

	protected function addUpdateNode(&$script)
	{
		$script .= "
	/**
	 * Move \$node and its children to location \$dest and updates rest of tree
	 *
	 * @param object Propel object for node to update
	 * @param PDO \$con      Connection to use.
	 * @param int	 Destination left value
	 */
	protected static function updateNode(\$node, \$destLeft, PDO \$con = null)
	{
		if (!is_object(\$node)) {
			return false;
		}

		\$left = \$node->getLeftValue();
		\$right = \$node->getRightValue();

		\$treeSize = \$right - \$left +1;

		self::shiftRLValues(\$destLeft, \$treeSize, \$con);

		if (\$left >= \$destLeft) { // src was shifted too?
			\$left += \$treeSize;
			\$right += \$treeSize;
		}

		// now there's enough room next to target to move the subtree
		\$newPos = self::shiftRLRange(\$left, \$right, \$destLeft - \$left, \$con);
		// correct values after source

		self::shiftRLValues(\$right + 1, -\$treeSize, \$con);

		// don't get what this if for?
		if (\$left <= \$destLeft) { // dst was shifted too?
			\$newPos['left'] -= \$treeSize;
			\$newPos['right'] -= \$treeSize;
		}
	}
";
	}

	protected function addShiftRLValues(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Adds '\$delta' to all L and R values that are >= '\$first'. '\$delta' can also be negative.
	 *
	 * @param int \$first 		First node to be shifted
	 * @param int \$delta 		Value to be shifted by, can be negative
	 * @param PDO \$con      Connection to use.
	 */
	protected static function shiftRLValues(\$first, \$delta, PDO \$con = null)
	{
		if (\$con === null) {
			\$con = Propel::getConnection($peerClassname::DATABASE_NAME);
		}

		// do that prepared thing so they must both execute to work
		// Shift left column values
		\$sql =	\"UPDATE \" . self::TABLE_NAME . \" SET \" . self::LEFT_COL . \"=\" . self::LEFT_COL . \" + ? WHERE \" . self::LEFT_COL . \" >= ?\";
		\$stmt = \$con->prepare(\$sql);
		\$stmt->bindParam(1, \$delta, PDO::PARAM_INT);
		\$stmt->bindParam(2, \$first, PDO::PARAM_INT);
		\$result = \$stmt->execute();

		// Shift right column values
		\$sql =	\"UPDATE \" . self::TABLE_NAME . \" SET \" . self::RIGHT_COL . \"=\" . self::RIGHT_COL . \" + ? WHERE \" . self::RIGHT_COL . \" >= ?\";
		\$stmt = \$con->prepare(\$sql);
		\$stmt->bindParam(1, \$delta, PDO::PARAM_INT);
		\$stmt->bindParam(2, \$first, PDO::PARAM_INT);
		\$result = \$stmt->execute();

	}
";
	}

	protected function addShiftRLRange(&$script)
	{
		$peerClassname = $this->getStubPeerBuilder()->getClassname();
		$script .= "
	/**
	 * Adds '\$delta' to all L and R values that are >= '\$first' and <= '\$last'.
	 * '\$delta' can also be negative.
	 *
	 * @param int \$first 	First node to be shifted (L value)
	 * @param int \$last 	Last node to be shifted (L value)
	 * @param int \$delta	 	Value to be shifted by, can be negative
	 * @param PDO \$con      Connection to use.
	 * @return array 		Shifted L and R values
	 */
 	protected static function shiftRLRange(\$first, \$last, \$delta, PDO \$con = null)
	{
		if (\$con === null) {
			\$con = Propel::getConnection($peerClassname::DATABASE_NAME);
		}

		// do that prepared thing so they must both execute to work
		// Shift left column values
		\$sql =	\"UPDATE \" . self::TABLE_NAME . \" SET \" . self::LEFT_COL . \"=\" . self::LEFT_COL . \" + ? WHERE \" . self::LEFT_COL . \" >= ? AND \" . self::LEFT_COL . \" <= ?\";
		\$stmt = \$con->prepare(\$sql);
		\$stmt->bindParam(1, \$delta, PDO::PARAM_INT);
		\$stmt->bindParam(2, \$first, PDO::PARAM_INT);
		\$stmt->bindParam(3, \$last, PDO::PARAM_INT);
		\$stmt->setFetchMode(PDO::FETCH_ASSOC);
		\$result = \$stmt->execute();

		// Shift right column values
		\$sql =	\"UPDATE \" . self::TABLE_NAME . \" SET \" . self::RIGHT_COL . \"=\" . self::RIGHT_COL . \" + ? WHERE \" . self::RIGHT_COL . \" >= ? AND \" . self::RIGHT_COL . \" <= ?\";
		\$stmt = \$con->prepare(\$sql);
		\$stmt->bindParam(1, \$delta, PDO::PARAM_INT);
		\$stmt->bindParam(2, \$first, PDO::PARAM_INT);
		\$stmt->bindParam(3, \$last, PDO::PARAM_INT);
		\$stmt->setFetchMode(PDO::FETCH_ASSOC);
		\$result = \$stmt->execute();

		return array('left' => \$first + \$delta, 'right' => \$last + \$delta);
	}
";
	}

} // PHP5NodePeerBuilder

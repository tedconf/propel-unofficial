<?php

/*
 *  $Id$
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * This software consists of voluntary contributions made by many individuals
 * and is licensed under the LGPL. For more information please see
 * <http://propel.phpdb.org>.
 */

require_once 'propel/engine/builder/om/PeerBuilder.php';

/**
 * Generates a PHP5 base Peer class for user object model (OM).
 *
 * This class produces the base peer class (e.g. BaseMyPeer) which contains all
 * the custom-built query and manipulator methods.
 *
 * This class replaces the Peer.tpl, with the intent of being easier for users
 * to customize (through extending & overriding).
 *
 * @author Hans Lellelid <hans@xmpl.org>
 * @package propel.engine.builder.om.php5
 */
class PHP5BasicPeerBuilder extends PeerBuilder {

	/**
	 * Returns the name of the current class being built.
	 * @return string
	 */
	public function getClassname()
	{
		return $this->getBuildProperty('basePrefix') . $this->getStubPeerBuilder()->getClassname();
	}

	/**
	 * Gets the package for the [base] peer classes.
	 * @return string
	 */
	public function getPackage()
	{
		return parent::getPackage() . ".om";
	}

	/**
	 * Adds the include() statements for files that this class depends on or utilizes.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addIncludes(&$script) {

		$table = $this->getTable();

		$basePeerFile = $this->getFilePath($this->basePeerClass);
		$objectFile = $this->getStubObjectBuilder()->getClassFilePath();

		$script .= "
require_once '$basePeerFile';
// The object class -- needed for instanceof checks in this class.
// actual class may be a subclass -- as returned by ".$this->getPeerClassname()."::getOMClass()
include_once '$objectFile';";

		$script .= "
";

	} // addIncludes()

	/**
	 * Adds class phpdoc comment and openning of class.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addClassOpen(&$script) {

		$tableName = $this->getTable()->getName();
		$tableDesc = $this->getTable()->getDescription();

		$script .= "
/**
 * Base static class for performing query and update operations on the '$tableName' table.
 *
 * $tableDesc
 *";
		if ($this->getBuildProperty('addTimeStamp')) {
			$now = strftime('%c');
			$script .= "
 * This class was autogenerated by Propel on:
 *
 * $now
 *";
		}
		$script .= "
 * @package ".$this->getPackage()."
 */
abstract class ".$this->getClassname()." {
";
	}

	/**
	 * Closes class.
	 * Adds closing brace at end of class and the static map builder registration code.
	 * @param string &$script The script will be modified in this method.
	 * @see addStaticMapBuilderRegistration()
	 */
	protected function addClassClose(&$script)
	{
		$script .= "
} // " . $this->getClassname() . "
";
	}

	/**
	 * Adds constant and variable declarations that go at the top of the class.
	 * @param string &$script The script will be modified in this method.
	 * @see addColumnNameConstants()
	 */
	protected function addConstantsAndAttributes(&$script)
	{
		$tableName = $this->getTable()->getName();
		$dbName = $this->getDatabase()->getName();
		$script .= "
	/** the default database name for this class */
	const DATABASE_NAME = '$dbName';

	/** the table name for this class */
	const TABLE_NAME = '$tableName';

	/** A class that can be returned by this peer. */
	const CLASS_DEFAULT = '".$this->getStubObjectBuilder()->getClasspath()."';

	/** The total number of columns. */
	const NUM_COLUMNS = ".$this->getTable()->getNumColumns().";

	/** The number of lazy-loaded columns. */
	const NUM_LAZY_LOAD_COLUMNS = ".$this->getTable()->getNumLazyLoadColumns().";

";
		$this->addColumnNameConstants($script);
		$this->addInheritanceColumnConstants($script);

		$script .= "
	/**
	 * An identiy map to hold any loaded instances of ".$this->getObjectClassname()." objects.
	 * This must be public so that other peer classes can access this when hydrating from JOIN
	 * queries.
	 * @var array ".$this->getObjectClassname()."[]
	 */
	public static \$instances = array();
	
	/**
	 * The MapBuilder instance for this peer.
	 * @var MapBuilder
	 */
	private static \$mapBuilder = null;
	
";
		
		$this->addFieldNamesAttribute($script);
		$this->addFieldKeysAttribute($script);
		
	}

	/**
	 * Adds the COLUMN_NAME contants to the class definition.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addColumnNameConstants(&$script)
	{
		foreach ($this->getTable()->getColumns() as $col) {

			$script .= "
	/** the column name for the [".$col->getName()."] column */
	const ".$this->getColumnName($col) ." = '".$col->getName()."';
";
		} // foreach
	}

	protected function addFieldNamesAttribute(&$script)
	{
		$table = $this->getTable();

		$tableColumns = $table->getColumns();
		$tablePhpname = $table->getPhpName();

		$script .= "
	/**
	 * holds an array of fieldnames
	 *
	 * first dimension keys are the type constants
	 * e.g. self::\$fieldNames[self::TYPE_PHPNAME][0] = 'Id'
	 */
	private static \$fieldNames = array (
		BasePeer::TYPE_PHPNAME => array (";
		foreach ($tableColumns as $col) {
			$script .= "'".$col->getPhpName()."', ";
		}
		$script .= "),
		BasePeer::TYPE_COLNAME => array (";
		foreach ($tableColumns as $col) {
			$script .= $this->getColumnConstant($col).", ";
		}
		$script .= "),
		BasePeer::TYPE_FIELDNAME => array (";
		foreach ($tableColumns as $col) {
			$script .= "'".$col->getName()."', ";
		}
		$script .= "),
		BasePeer::TYPE_NUM => array (";
		foreach ($tableColumns as $num => $col) {
			$script .= "$num, ";
		}
		$script .= ")
	);
";
	}

	protected function addFieldKeysAttribute(&$script)
	{
		$table = $this->getTable();

		$tableColumns = $table->getColumns();
		$tablePhpname = $table->getPhpName();

		$script .= "
	/**
	 * holds an array of keys for quick access to the fieldnames array
	 *
	 * first dimension keys are the type constants
	 * e.g. self::\$fieldNames[BasePeer::TYPE_PHPNAME]['Id'] = 0
	 */
	private static \$fieldKeys = array (
		BasePeer::TYPE_PHPNAME => array (";
		foreach ($tableColumns as $num => $col) {
			$script .= "'".$col->getPhpName()."' => $num, ";
		}
		$script .= "),
		BasePeer::TYPE_COLNAME => array (";
		foreach ($tableColumns as $num => $col) {
			$script .= $this->getColumnConstant($col)." => $num, ";
		}
		$script .= "),
		BasePeer::TYPE_FIELDNAME => array (";
		foreach ($tableColumns as $num => $col) {
			$script .= "'".$col->getName()."' => $num, ";
		}
		$script .= "),
		BasePeer::TYPE_NUM => array (";
		foreach ($tableColumns as $num => $col) {
			$script .= "$num, ";
		}
		$script .= ")
	);
";
	} // addFielKeysAttribute


	protected function addGetFieldNames(&$script)
	{
		$script .= "
	/**
	 * Returns an array of of field names.
	 *
	 * @param  string \$type The type of fieldnames to return:
	 *                      One of the class type constants TYPE_PHPNAME,
	 *                      TYPE_COLNAME, TYPE_FIELDNAME, TYPE_NUM
	 * @return array A list of field names
	 */

	static public function getFieldNames(\$type = BasePeer::TYPE_PHPNAME)
	{
		if (!array_key_exists(\$type, self::\$fieldNames)) {
			throw new PropelException('Method getFieldNames() expects the parameter \$type to be one of the class constants TYPE_PHPNAME, TYPE_COLNAME, TYPE_FIELDNAME, TYPE_NUM. ' . \$type . ' was given.');
		}
		return self::\$fieldNames[\$type];
	}
";

	} // addGetFieldNames()

	protected function addTranslateFieldName(&$script)
	{
		$script .= "
	/**
	 * Translates a fieldname to another type
	 *
	 * @param string \$name field name
	 * @param string \$fromType One of the class type constants TYPE_PHPNAME,
	 *                         TYPE_COLNAME, TYPE_FIELDNAME, TYPE_NUM
	 * @param string \$toType   One of the class type constants
	 * @return string translated name of the field.
	 */
	static public function translateFieldName(\$name, \$fromType, \$toType)
	{
		\$toNames = self::getFieldNames(\$toType);
		\$key = isset(self::\$fieldKeys[\$fromType][\$name]) ? self::\$fieldKeys[\$fromType][\$name] : null;
		if (\$key === null) {
			throw new PropelException(\"'\$name' could not be found in the field names of type '\$fromType'. These are: \" . print_r(self::\$fieldKeys[\$fromType], true));
		}
		return \$toNames[\$key];
	}
";
	} // addTranslateFieldName()
	
	/**
	 * Adds the createCriteria() method.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addCreateCriteria(&$script)
	{
		$script .= "
	/**
	 * Create a new Criteria object for use with this table.
	 * @param string \$alias The table alias to use for this Criteria.
	 */
	public static function createCriteria(\$alias = null)
	{
		return new Criteria(".$this->getPeerClassname()."::createQueryTable(\$alias));
	}
";
	}
	
	/**
	 * Adds the createQuery() method.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addCreateQuery(&$script)
	{
		$script .= "
	/**
	 * Create a new Query object for use with this table.
	 * @param Criteria \$criteria The Criteria to use for this query. 
	 */
	public static function createQuery(Criteria \$criteria = null)
	{
		if (\$criteria === null) {
			\$criteria = ".$this->getPeerClassname()."::createCriteria();
		}
		return new Query(\$criteria);
	}
";
	}
	
	/**
	 * Adds the createQueryTable() method.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addCreateQueryTable(&$script)
	{
		$script .= "
	/**
	 * Create a new QueryTable object representing this table for use in a query.
	 * @param string \$alias The table alias to use for this QueryTable.
	 */
	public static function createQueryTable(\$alias = null)
	{
		return new QueryTable(".$this->getPeerClassname()."::getTableMap(), \$alias);
	}
";
	}
	
	/**
	 * Adds the getMapBuilder() method.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addGetMapBuilder(&$script)
	{
		$script .= "
	/**
	 * Get a (singleton) instance of the MapBuilder for this peer class.
	 * @return MapBuilder The map builder for this peer
	 */
	public static function getMapBuilder()
	{
		if (self::\$mapBuilder === null) {
			include_once '" . $this->getMapBuilderBuilder()->getClassFilePath()."';
			self::\$mapBuilder = new ".$this->getMapBuilderBuilder()->getClassname()."();
		}
		return self::\$mapBuilder;
	}";
	}

	/**
	 * Adds the CLASSKEY_* and CLASSNAME_* constants used for inheritance.
	 * @param string &$script The script will be modified in this method.
	 */
	public function addInheritanceColumnConstants(&$script)
	{
		if ($this->getTable()->getChildrenColumn()) {

			$col = $this->getTable()->getChildrenColumn();
			$tfc = $this->getTable()->getPhpName();
			$cfc = $col->getPhpName();

			if ($col->isEnumeratedClasses()) {

				if ($col->isPrimitiveNumeric()) $quote = "";
				else $quote = '"';

				foreach ($col->getChildren() as $child) {
					$childBuilder = $this->getMultiExtendObjectBuilder();
					$childBuilder->setChild($child);

					$script .= "
	/** A key representing a particular subclass */
	const CLASSKEY_".strtoupper($child->getKey())." = '" . $child->getKey() . "';

	/** A key representing a particular subclass */
	const CLASSKEY_".strtoupper($child->getClassName())." = '" . $child->getKey() . "';

	/** A class that can be returned by this peer. */
	const CLASSNAME_".strtoupper($child->getKey())." = '". $childBuilder->getClasspath() . "';
";
				} /* foreach children */
			} /* if col->isenumerated...() */
		} /* if table->getchildrencolumn() */

	}

	/**
	 * Adds the COUNT constants.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addCountConstants(&$script)
	{
		$table = $this->getTable();
		$count_col = "*";
		/*
		* FIXME
		* (HL) wanted to remove this because AFAIK count(*) is generally
		* optimized in databases, and furthermore the code below isn't correct
		* (multi-pkey needs to be accounted for)....
		*/
		if ($table->hasPrimaryKey()) {
			$pk = $table->getPrimaryKey();
			$count_col = $table->getName().".".strtoupper($pk[0]->getName());
		}

		$script .= "
	const COUNT = 'COUNT(\$1%s.$count_col)';
	const COUNT_DISTINCT = 'COUNT(DISTINCT \$1%s.$count_col)';
";
	}

	/**
	 * Adds the doCount() method.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addDoCount(&$script)
	{
		$script .= "
	/**
	 * Returns the number of rows matching criteria.
	 *
	 * @param Query \$query
	 * @param Connection \$con
	 * @return int Number of matching rows.
	 */
	public static function doCount(Query \$query, PDO \$con = null)
	{
		// we're going to modify criteria, so copy it first
		\$query = clone(\$query);

		// clear out anything that might confuse the ORDER BY clause
		\$query->clearSelectColumns()->clearOrderByColumns();
		
		if (in_array(Query::DISTINCT, \$query->getSelectModifiers())) {
			\$criteria->addSelectColumn(new VirtualQueryColumn(".$this->getPeerClassname()."::COUNT_DISTINCT));
		} else {
			\$criteria->addSelectColumn(new VirtualQueryColumn(".$this->getPeerClassname()."::COUNT));
		}

		// just in case we're grouping: add those columns to the select statement
		foreach(\$criteria->getGroupByColumns() as \$column)
		{
			\$criteria->addSelectColumn(\$column);
		}

		\$stmt = ".$this->getPeerClassname()."::doSelectRS(\$query, \$con);
		if (\$row = \$stmt->fetch(PDO::FETCH_NUM)) {
			return \$row[0];
		} else {
			// no rows returned; we infer that means 0 matches.
			return 0;
		}
	}";
	}

	/**
	 * Adds the doSelectOne() method.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addDoSelectOne(&$script)
	{
		$script .= "
	/**
	 * Method to select one object from the DB.
	 *
	 * @param Query \$query Query object used to create the SELECT statement.
	 * @param PDO \$con
	 * @return ".$this->getObjectClassname()."
	 * @throws PropelException Any exceptions caught during processing will be
	 *		 rethrown wrapped into a PropelException.
	 */
	public static function doSelectOne(Query \$query, PDO \$con = null)
	{
		\$query = clone(\$query); // A shallow clone is actually OK here, because we're only
								  // changing the limit (a scalar)
		\$query->setLimit(1);
		\$objects = ".$this->getPeerClassname()."::doSelect(\$query, \$con);
		if (\$objects) {
			return \$objects[0];
		}
		return null;
	}";
	}

	/**
	 * Adds the doSelect() method.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addDoSelect(&$script)
	{
		$script .= "
	/**
	 * Method to do selects.
	 *
	 * @param Query \$query Query object used to create the SELECT statement.
	 * @param PDO \$con
	 * @return array Array of selected Objects
	 * @throws PropelException Any exceptions caught during processing will be
	 *		 rethrown wrapped into a PropelException.
	 */
	public static function doSelect(Query \$query, PDO \$con = null)
	{
		return ".$this->getPeerClassname()."::populateObjects(".$this->getPeerClassname()."::doSelectStmt(\$query, \$con));
	}";
	}

	/**
	 * Adds the doSelectRS() method.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addDoSelectRS(&$script)
	{

		$script .= "
	/**
	 * Prepares the Query object and uses the ".$this->basePeerClassname."::doSelect()
	 * method to get a result set.
	 *
	 * Use this method directly if you want to just get the PDOStatement result set
	 * (instead of an array of objects).
	 *
	 * @param Query \$query The Query object used to build the SELECT statement.
	 * @param PDO \$con the connection to use
	 * @throws PropelException Any exceptions caught during processing will be
	 *		 rethrown wrapped into a PropelException.
	 * @return PDOStatement The PDO resultset object.
	 * @see ".$this->basePeerClassname."::doSelect()
	 */
	public static function doSelectStmt(Query \$query, PDO \$con = null)
	{
		if (\$con === null) {
			\$con = Propel::getConnection(".$this->getPeerClassname()."::DATABASE_NAME);
		}
		
		if (!\$query->getSelectColumns()) {
			\$query = clone(\$query);	// Here a shallow copy is OK, because we're not changing any
										// of the embedded objects themselves; we're just adding references 
										// to the Query objec.
			\$query->addDefaultSelectColumns();
		}
		
		// BasePeer returns a PDOStatement
		return ".$this->basePeerClassname."::doSelect(\$query, \$con);
	}
";
	}
	
	/**
	 * Adds method to get a version of the primary key that can be used as a unique key for identifier map.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addGetPrimaryKeyHash(&$script)
	{
		$script .= "
	/**
	 * Retrieves a string version of the primary key that can be used to uniquely identify a row in this table.
	 * 
	 * For tables with a single-column primary key, that simple pkey value will be returned.  For tables with
	 * a multi-column primary key, a serialize()d version of the primary key will be returned.
	 * 
	 * @param array \$row PDO resultset row.
	 * @param int \$startcol The 0-based offset for reading from the resultset row.
	 * @return string
	 */
	public static function getPrimaryKeyHash(\$row, \$startcol = 0)
	{";
		
		// We have to iterate through all the columns so that we know the offset of the primary 
		// key columns.
		$n = 0;
		foreach($this->getTable()->getColumns() as $col) {
			if(!$col->isLazyLoad()) {
				if ($col->isPrimaryKey()) {
					$pk[] = "\$row[\$startcol + $n]";
				}
				$n++;
			}
		}
		
		// the general case is a single column		
		if (count($pk) == 1) {					
			$script .= "
		return (string) ".$pk[0].";";
		} else {
			$script .= "
		return serialize(array(".implode(',', $pk)."));";			
		}
		
		$script .= "
	}
";
	} // addGetPrimaryKeyHash
	
	/**
	 * Adds the populateObjects() method.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addPopulateObjects(&$script)
	{
		$table = $this->getTable();
		$script .= "
	/**
	 * The returned array will contain objects of the default type or
	 * objects that inherit from the default.
	 *
	 * @throws PropelException Any exceptions caught during processing will be
	 *		 rethrown wrapped into a PropelException.
	 */
	public static function populateObjects(PDOStatement \$stmt)
	{
		\$results = array();
	";
		if (!$table->getChildrenColumn()) {
			$script .= "
		// set the class once to avoid overhead in the loop
		\$cls = ".$this->getPeerClassname()."::getOMClass();
		\$cls = Propel::import(\$cls);";
		}

		$script .= "
		// populate the object(s)
		while(\$row = \$stmt->fetch(PDO::FETCH_NUM)) {
			\$key = ".$this->getPeerClassname()."::getPrimaryKeyHash(\$row, 0);
			if (isset(self::\$instances[\$key])) {
				\$results[] = self::\$instances[\$key];
			} else {
		";
		if ($table->getChildrenColumn()) {
			$script .= "
				// class must be set each time from the record row
				\$cls = Propel::import(".$this->getPeerClassname()."::getOMClass(\$row, 0));
				\$obj = new \$cls();
				\$obj->hydrate(\$row);
				\$results[] = \$obj;
				self::\$instances[\$key] = \$obj;";
		} else {
			$script .= "
				\$obj = new \$cls();
				\$obj->hydrate(\$row);
				\$results[] = \$obj;
				self::\$instances[\$key] = \$obj;";
		}
		$script .= "
			} // if key exists
		}
		return \$results;
	}";
	}

	/**
	 * Adds a getOMClass() for non-abstract tables that have inheritance.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addGetOMClass_Inheritance(&$script)
	{
		$col = $this->getTable()->getChildrenColumn();
		$script .= "
	/**
	 * The returned Class will contain objects of the default type or
	 * objects that inherit from the default.
	 *
	 * @param array \$row PDO result row.
	 * @param int \$colnum Column to examine for OM class information (first is 0).
	 * @throws PropelException Any exceptions caught during processing will be
	 *		 rethrown wrapped into a PropelException.
	 */
	public static function getOMClass(\$row, \$colnum)
	{
		try {
";
		if ($col->isEnumeratedClasses()) {
			$script .= "
			\$omClass = null;
			\$classKey = \$row[\$colnum + " . ($col->getPosition() - 1) . "];

			switch(\$classKey) {
";
			foreach ($col->getChildren() as $child) {
				$script .= "
				case self::CLASSKEY_".$child->getKey().":
					\$omClass = self::CLASSNAME_".strtoupper($child->getKey()).";
					break;
";
			} /* foreach */
			$script .= "
				default:
					\$omClass = self::CLASS_DEFAULT;
";
			$script .= "
			} // switch
";
		} else { /* if not enumerated */
			$script .= "
			\$omClass = Propel::import(\$row[\$colnum + ".($col->getPosition()-1)."));
";
		}
		$script .= "
		} catch (Exception \$e) {
			throw new PropelException('Unable to get OM class.', \$e);
		}
		return \$omClass;
	}
";
	}

	/**
	 * Adds a getOMClass() signature for abstract tables that have inheritance.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addGetOMClass_Inheritance_Abstract(&$script)
	{
		$script .= "
	/**
	 * The returned Class will contain objects of the default type or
	 * objects that inherit from the default.
	 *
	 * This method must be overridden by the stub subclass, because
	 * ".$this->getTable()->getPhpName()." is declared abstract in the schema.
	 *
	 * @param ResultSet \$rs ResultSet with pointer to record containing om class.
	 * @param int \$colnum Column to examine for OM class information (first is 1).
	 * @throws PropelException Any exceptions caught during processing will be
	 *		 rethrown wrapped into a PropelException.
	 */
	abstract public static function getOMClass();
";
	}

	/**
	 * Adds a getOMClass() for non-abstract tables that do note use inheritance.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addGetOMClass_NoInheritance(&$script)
	{
		$script .= "
	/**
	 * The class that the Peer will make instances of.
	 *
	 * This uses a dot-path notation which is tranalted into a path
	 * relative to a location on the PHP include_path.
	 * (e.g. path.to.MyClass -> 'path/to/MyClass.php')
	 *
	 * @return string path.to.ClassName
	 */
	public static function getOMClass()
	{
		return ".$this->getPeerClassname()."::CLASS_DEFAULT;
	}
";
	}

	/**
	 * Adds a getOMClass() signature for abstract tables that do not have inheritance.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addGetOMClass_NoInheritance_Abstract(&$script)
	{
		$script .= "
	/**
	 * The class that the Peer will make instances of.
	 *
	 * This method must be overridden by the stub subclass, because
	 * ".$this->getTable()->getPhpName()." is declared abstract in the schema.
	 */
	abstract public static function getOMClass();
";
	}

	/**
	 * Adds the doInsert() method.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addDoInsert(&$script)
	{
		$table = $this->getTable();
		$script .= "
	/**
	 * Method perform an INSERT on the database, given a ".$table->getPhpName()." or Criteria object.
	 *
	 * @param mixed \$values Criteria or ".$table->getPhpName()." object containing data that is used to create the INSERT statement.
	 * @param PDO \$con the PDO connection to use
	 * @return mixed The new primary key.
	 * @throws PropelException Any exceptions caught during processing will be
	 *		 rethrown wrapped into a PropelException.
	 */
	public static function doInsert(\$values, PDO \$con = null)
	{
		if (\$con === null) {
			\$con = Propel::getConnection(self::DATABASE_NAME);
		}

		if (\$values instanceof ColumnValueCollection) {
			\$values = clone \$values; // FIXME - here we need a deep copy() because we are going to change embedded objects
		} else {
			\$values = \$values->buildColumnValueCollection();
		}
";

		foreach ($table->getColumns() as $col) {
			$cfc = $col->getPhpName();
			if ($col->isPrimaryKey() && $col->isAutoIncrement() && $table->getIdMethod() != "none") {
				$script .= "
		\$values->remove(".$this->getColumnConstant($col)."); // remove pkey col since this table uses auto-increment
";
			}
		}
		$script .= "
		try {
			Transaction::begin(\$con);
			\$pk = ".$this->basePeerClassname."::doInsert(\$values, \$con);
			Transaction::commit(\$con);
		} catch(PropelException \$e) {
			Transaction::rollback(\$con);
			throw \$e;
		}

		return \$pk;
	}
";
	}

	/**
	 * Adds the doUpdate() method.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addDoUpdate(&$script)
	{
		$table = $this->getTable();
		$script .= "
	/**
	 * Method perform an UPDATE on the database, given a ".$table->getPhpName()." or ColumnValueCollection object.
	 *
	 * @param mixed \$values Criteria or ".$table->getPhpName()." object containing data that is used to create the UPDATE statement.
	 * @param Connection \$con The connection to use (specify Connection object to exert more control over transactions).
	 * @return int The number of affected rows (if supported by underlying database driver).
	 * @throws PropelException Any exceptions caught during processing will be
	 *		 rethrown wrapped into a PropelException.
	 */
	public static function doUpdate(\$obj, PDO \$con = null)
	{
		if (\$con === null) {
			\$con = Propel::getConnection(".$this->getPeerClassname()."::DATABASE_NAME);
		}
		
		if (\$obj instanceof ColumnValueCollection) {
			\$values = clone \$obj; // FIXME - here we need a deep copy, because we are modifying internal objects 
			\$selectCriteria = ".$this->getPeerClassname()."::createCriteria();";
		foreach ($table->getColumns() as $col) {
			if($col->isPrimaryKey()) {
				$script .= "
			\$selectCriteria->add(new EqualExpr(".$this->getColumnConstant($col).", \$values->remove(".$this->getColumnConstant($col).")));
";
			}  /* if col is prim key */
	 	} /* foreach */

		$script .= "
		} else { // \$values is ".$table->getPhpName()." object
			\$selectCriteria = \$obj->buildPkeyCriteria(); // gets criteria w/ primary key(s)
			\$values = \$obj->buildColumnValueCollection();			
		}

		return ".$this->basePeerClassname."::doUpdate(\$selectCriteria, \$values, \$con);
	}
";
	}

	/**
	 * Adds the doDeleteAll() method.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addDoDeleteAll(&$script)
	{
		$table = $this->getTable();
		$script .= "
	/**
	 * Method to DELETE all rows from the ".$table->getName()." table.
	 *
	 * @return int The number of affected rows (if supported by underlying database driver).
	 */
	public static function doDeleteAll(PDO \$con = null)
	{
		if (\$con === null) {
			\$con = Propel::getConnection(self::DATABASE_NAME);
		}
		\$affectedRows = 0; // initialize var to track total num of affected rows
		try {
			// use transaction because \$criteria could contain info
			// for more than one table or we could emulating ON DELETE CASCADE, etc.
			Transaction::begin(\$con);
			";
			if ($this->isDeleteCascadeEmulationNeeded()) {
			    $script .="\$affectedRows += ".$this->getPeerClassname()."::doOnDeleteCascade(new Criteria(), \$con);
			";
			}
			if ($this->isDeleteSetNullEmulationNeeded()) {
				$script .= $this->getPeerClassname() . "::doOnDeleteSetNull(new Criteria(), \$con);
			";
			}
			$script .= "\$affectedRows += BasePeer::doDeleteAll(".$this->getPeerClassname()."::TABLE_NAME, \$con);
			Transaction::commit(\$con);
			return \$affectedRows;
		} catch (PropelException \$e) {
			Transaction::rollback(\$con);
			throw \$e;
		}
	}
";
	}

	/**
	 * Adds the doDelete() method.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addDoDelete(&$script)
	{
		$table = $this->getTable();
		$script .= "
	/**
	 * Method perform a DELETE on the database, given a ".$table->getPhpName()." or Criteria object OR a primary key value.
	 *
	 * @param mixed \$values Criteria or ".$table->getPhpName()." object or primary key or array of primary keys
	 *              which is used to create the DELETE statement
	 * @param Connection \$con the connection to use
	 * @return int 	The number of affected rows (if supported by underlying database driver).  This includes CASCADE-related rows
	 *				if supported by native driver or if emulated using Propel.
	 * @throws PropelException Any exceptions caught during processing will be
	 *		 rethrown wrapped into a PropelException.
	 */
	 public static function doDelete(\$obj, PDO \$con = null)
	 {
		if (\$con === null) {
			\$con = Propel::getConnection(".$this->getPeerClassname()."::DATABASE_NAME);
		}

		if (\$obj instanceof Criteria) {
			\$criteria = clone \$obj; // FIXME - here we need a deep copy because internal objects are being changed
		} elseif (\$obj instanceof ".$table->getPhpName().") {
";
		if (count($table->getPrimaryKey()) > 0) {
			$script .= "
			\$criteria = \$obj->buildPkeyCriteria();";
		} else {
			$script .= "
			// this table has no primary key, so we build a Criteria that contains
			// all the columns from the object
			\$criteria = ".$this->getPeerClassname()."::createCriteria();			
			foreach(\$obj->buildColumnValueCollection() as \$cv) {
				\$criteria->add(EqualExpr(\$cv->getColumnMap()->getName(), \$cv->getValue()));
			}
";
		}

		$script .= "
		} else {
			throw new PropelException(\"Inavlid parameter passed to ".$this->getPeerClassname()."::doDelete(): \" . var_export(\$obj, true)); 
		}

		\$affectedRows = 0; // initialize var to track total num of affected rows

		try {
			// use transaction because \$criteria could contain info
			// for more than one table or we could emulating ON DELETE CASCADE, etc.
			Transaction::begin(\$con);
			";

		if ($this->isDeleteCascadeEmulationNeeded()) {
		    $script .= "\$affectedRows += ".$this->getPeerClassname()."::doOnDeleteCascade(\$criteria, \$con);";
		}
		if ($this->isDeleteSetNullEmulationNeeded()) {
			$script .= $this->getPeerClassname() . "::doOnDeleteSetNull(\$criteria, \$con);";
		}

		$script .= "
			\$affectedRows += ".$this->basePeerClassname."::doDelete(\$criteria, \$con);
			Transaction::commit(\$con);
			return \$affectedRows;
		} catch (PropelException \$e) {
			Transaction::rollback(\$con);
			throw \$e;
		}
	}
";
	}

	/**
	 * Adds the doOnDeleteCascade() method, which provides ON DELETE CASCADE emulation.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addDoOnDeleteCascade(&$script)
	{
		$table = $this->getTable();
		$script .= "
	/**
	 * This is a method for emulating ON DELETE CASCADE for DBs that don't support this
	 * feature (like MySQL or SQLite).
	 *
	 * This method is not very speedy because it must perform a query first to get
	 * the implicated records and then perform the deletes by calling those Peer classes.
	 *
	 * This method should be used within a transaction if possible.
	 *
	 * @param Criteria \$criteria
	 * @param Connection \$con
	 * @return int The number of affected rows (if supported by underlying database driver).
	 */
	protected static function doOnDeleteCascade(Criteria \$criteria, Connection \$con)
	{
		// initialize var to track total num of affected rows
		\$affectedRows = 0;

		// first find the objects that are implicated by the \$criteria
		\$objects = ".$this->getPeerClassname()."::doSelect(\$criteria, \$con);
		foreach(\$objects as \$obj) {
";

		foreach ($table->getReferrers() as $fk) {

			// $fk is the foreign key in the other table, so localTableName will
			// actually be the table name of other table
			$tblFK = $fk->getTable();

			$joinedTablePeerBuilder = OMBuilder::getNewPeerBuilder($tblFK);
			$tblFKPackage = $joinedTablePeerBuilder->getStubPeerBuilder()->getPackage();

			if (!$tblFK->isForReferenceOnly()) {
				// we can't perform operations on tables that are
				// not within the schema (i.e. that we have no map for, etc.)

				$fkClassName = $tblFK->getPhpName();

				// i'm not sure whether we can allow delete cascade for foreign keys
				// within the same table?  perhaps we can?
				if ( $fk->getOnDelete() == ForeignKey::CASCADE && $tblFK->getName() != $table->getName()) {

					// backwards on purpose
					$columnNamesF = $fk->getLocalColumns();
					$columnNamesL = $fk->getForeignColumns();

					$script .= "

			include_once '".$this->getFilePath($tblFKPackage, $tblFK->getPhpName())."';

			// delete related $fkClassName objects
			\$c = new Criteria();
			";
					for($x=0,$xlen=count($columnNamesF); $x < $xlen; $x++) {
						$columnFK = $tblFK->getColumn($columnNamesF[$x]);
						$columnL = $table->getColumn($columnNamesL[$x]);

						$script .= "
			\$c->add(".$joinedTablePeerBuilder->getColumnConstant($columnFK) .", \$obj->get".$columnL->getPhpName()."());";
					}

					$script .= "
			\$affectedRows += ".$joinedTablePeerBuilder->getPeerClassname()."::doDelete(\$c, \$con);";

				} // if cascade && fkey table name != curr table name

			} // if not for ref only
		} // foreach foreign keys
			$script .= "
		}
		return \$affectedRows;
	}
";
	} // end addDoOnDeleteCascade

	/**
	 * Adds the doOnDeleteSetNull() method, which provides ON DELETE SET NULL emulation.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addDoOnDeleteSetNull(&$script)
	{
		$table = $this->getTable();
		$script .= "
	/**
	 * This is a method for emulating ON DELETE SET NULL DBs that don't support this
	 * feature (like MySQL or SQLite).
	 *
	 * This method is not very speedy because it must perform a query first to get
	 * the implicated records and then perform the deletes by calling those Peer classes.
	 *
	 * This method should be used within a transaction if possible.
	 *
	 * @param Criteria \$criteria
	 * @param Connection \$con
	 * @return void
	 */
	protected static function doOnDeleteSetNull(Criteria \$criteria, Connection \$con)
	{

		// first find the objects that are implicated by the \$criteria
		\$objects = ".$this->getPeerClassname()."::doSelect(\$criteria, \$con);
		foreach(\$objects as \$obj) {
";

		// This logic is almost exactly the same as that in doOnDeleteCascade()
		// it may make sense to refactor this, provided that thigns don't
		// get too complicated.

		foreach ($table->getReferrers() as $fk) {

			// $fk is the foreign key in the other table, so localTableName will
			// actually be the table name of other table
			$tblFK = $fk->getTable();
			$refTablePeerBuilder = OMBuilder::getNewPeerBuilder($tblFK);

			if (!$tblFK->isForReferenceOnly()) {
				// we can't perform operations on tables that are
				// not within the schema (i.e. that we have no map for, etc.)

				$fkClassName = $tblFK->getPhpName();

				// i'm not sure whether we can allow delete setnull for foreign keys
				// within the same table?  perhaps we can?
				if ( $fk->getOnDelete() == ForeignKey::SETNULL &&
						$fk->getTable()->getName() != $table->getName()) {

							// backwards on purpose
							$columnNamesF = $fk->getLocalColumns();
							$columnNamesL = $fk->getForeignColumns(); // should be same num as foreign
					$script .= "
			// set fkey col in related $fkClassName rows to NULL
			\$selectCriteria = new " . $this->getBuildProperty('criteriaClass') ."(".$this->getPeerClassname()."::DATABASE_NAME);
			\$updateValues = new Criteria(".$this->getPeerClassname()."::DATABASE_NAME);";

					for ($x=0,$xlen=count($columnNamesF); $x < $xlen; $x++) {
						$columnFK = $tblFK->getColumn($columnNamesF[$x]);
						$columnL = $table->getColumn($columnNamesL[$x]);
						$script .= "
			\$selectCriteria->add(".$refTablePeerBuilder->getColumnConstant($columnFK).", \$obj->get".$columnL->getPhpName()."());
			\$updateValues->add(".$refTablePeerBuilder->getColumnConstant($columnFK).", null);
";
					}

					$script .= "
			{$this->basePeerClassname}::doUpdate(\$selectCriteria, \$updateValues, \$con); // use BasePeer because generated Peer doUpdate() methods only update using pkey
";
				} // if setnull && fkey table name != curr table name
			} // if not for ref only
		} // foreach foreign keys

		$script .= "
		}
	}
";
	}

	/**
	 * Adds the doValidate() method.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addDoValidate(&$script)
	{
		$table = $this->getTable();
		$script .= "
	/**
	 * Validates all modified columns of given ".$table->getPhpName()." object.
	 * If parameter \$columns is either a single column name or an array of column names
	 * than only those columns are validated.
	 *
	 * NOTICE: This does not apply to primary or foreign keys for now.
	 *
	 * @param ".$table->getPhpName()." \$obj The object to validate.
	 * @param mixed \$cols Column name or array of column names.
	 *
	 * @return mixed TRUE if all columns are valid or the error message of the first invalid column.
	 */
	public static function doValidate(".$table->getPhpName()." \$obj, \$cols = null)
	{
		\$columns = array();

		if (\$cols) {
			\$dbMap = Propel::getDatabaseMap(".$this->getPeerClassname()."::DATABASE_NAME);
			\$tableMap = \$dbMap->getTable(".$this->getPeerClassname()."::TABLE_NAME);

			if (! is_array(\$cols)) {
				\$cols = array(\$cols);
			}

			foreach(\$cols as \$colName) {
				if (\$tableMap->containsColumn(\$colName)) {
					\$get = 'get' . \$tableMap->getColumn(\$colName)->getPhpName();
					\$columns[\$colName] = \$obj->\$get();
				}
			}
		} else {
";
		foreach ($table->getValidators() as $val) {
			$col = $val->getColumn();
			if (!$col->isAutoIncrement()) {
				$script .= "
		if (\$obj->isNew() || \$obj->isColumnModified(".$this->getColumnConstant($col)."))
			\$columns[".$this->getColumnConstant($col)."] = \$obj->get".$col->getPhpName()."();
";
			} // if
  		} // foreach

  		$script .= "
		}

		return {$this->basePeerClassname}::doValidate(".$this->getPeerClassname()."::DATABASE_NAME, ".$this->getPeerClassname()."::TABLE_NAME, \$columns);
	}
";
	} // end addDoValidate()

	/**
	 * Adds the retrieveByPK method for tables with single-column primary key.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addRetrieveByPK_SinglePK(&$script)
	{
		$table = $this->getTable();
		$script .= "
	/**
	 * Retrieve a single object by pkey.
	 *
	 * @param mixed \$pk the primary key.
	 * @param PDO \$con the connection to use
	 * @return " . $table->getPhpName() . "
	 */
	public static function ".$this->getRetrieveMethodName()."(\$pk, PDO \$con = null)
	{
		// shortcut to avoid calling doSelect() when we already know it's in the identity map
		\$key = (string) \$pk;
		if (isset(self::\$instances[\$key])) {
			return self::\$instances[\$key];
		} else {
			if (\$con === null) {
				\$con = Propel::getConnection(self::DATABASE_NAME);
			}
	
			\$criteria = " .$this->getPeerClassname()."::createCriteria();
";
		$pkey = $table->getPrimaryKey();
		$col = array_shift($pkey);
		$script .= "
			\$criteria->add(new EqualExpr(".$this->getColumnConstant($col).", \$pk));
";
		$script .= "
	
			\$v = ".$this->getPeerClassname()."::doSelectOne(new Query(\$criteria), \$con);
			if (\$v) { // only set the map, if it's an actual object
				self::\$instances[\$key] = \$v;
			}
			return \$v;
		}
	}
";
	}

	/**
	 * Adds the retrieveByPKs method for tables with single-column primary key.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addRetrieveByPKs_SinglePK(&$script)
	{
		$table = $this->getTable();
		$script .= "
	/**
	 * Retrieve multiple objects by pkey.
	 *
	 * @param array \$pks List of primary keys
	 * @param Connection \$con the connection to use
	 * @throws PropelException Any exceptions caught during processing will be
	 *		 rethrown wrapped into a PropelException.
	 */
	public static function ".$this->getRetrieveMethodName()."s(\$pks, PDO \$con = null)
	{
		if (\$con === null) {
			\$con = Propel::getConnection(".$this->getPeerClassname()."::DATABASE_NAME);
		}

		\$objs = null;
		if (empty(\$pks)) {
			\$objs = array();
		} else {
			\$criteria = ".$this->getPeerClassname()."::createCriteria();";
					
		$k1 = $table->getPrimaryKey();
		$script .= "
			\$criteria->add(new InExpr(".$this->getColumnConstant($k1[0]).", \$pks));";
	
		$script .= "
			\$objs = ".$this->getPeerClassname()."::doSelect(new Query(\$criteria), \$con);
		}
		return \$objs;
	}
";
	}

	/**
	 * Adds the retrieveByPK method for tables with multi-column primary key.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addRetrieveByPK_MultiPK(&$script)
	{
		$table = $this->getTable();
		$script .= "
	/**
	 * Retrieve object using using composite pkey values.
	";
		foreach ($table->getPrimaryKey() as $col) {
			$clo = strtolower($col->getName());
			$cptype = $col->getPhpNative();
			$script .= " * @param $cptype $".$clo."
	";
	   }
	   $script .= " * @param Connection \$con
	 * @return ".$table->getPhpName()."
	 */
	public static function ".$this->getRetrieveMethodName()."(";
		
		$params = array();
		foreach ($table->getPrimaryKey() as $col) {
			$clo = strtolower($col->getName());
			$params[] = "\$".$clo;
		} /* foreach */
		
		$script .= implode(', ', $params);
		
		$script .= ", PDO \$con = null)
	{
		\$instanceKey = serialize(array(".implode(',',$params)."));
		if (isset(self::\$instances[\$instanceKey])) {
			return self::\$instances[\$instanceKey];
		} else {
			if (\$con === null) {
				\$con = Propel::getConnection(".$this->getPeerClassname()."::DATABASE_NAME);
			}
			\$criteria = ".$this->getPeerClassname()."::createCriteria();";
		foreach ($table->getPrimaryKey() as $col) {
			$clo = strtolower($col->getName());
			$script .= "
			\$criteria->add(new EqualExpr(".$this->getColumnConstant($col).", $".$clo."));";
		}
		$script .= "
			\$v = ".$this->getPeerClassname()."::doSelectOne(new Query(\$criteria), \$con);
			if (\$v) { // only set the map, if it's an actual object
				self::\$instances[\$instanceKey] = \$v;
			}
			return \$v;
		}
	}";
	}

	/**
	 * Adds the getTableMap() method which is a convenience method for apps to get DB metadata.
	 * @param string &$script The script will be modified in this method.
	 */
	protected function addGetTableMap(&$script)
	{
		$script .= "
	/**
	 * Returns the TableMap related to this peer.
	 * This method is not needed for general use but a specific application could have a need.
	 * @return TableMap
	 * @throws PropelException Any exceptions caught during processing will be
	 *		 rethrown wrapped into a PropelException.
	 */
	public static function getTableMap()
	{
		return Propel::getDatabaseMap(".$this->getPeerClassname()."::DATABASE_NAME)->getTable(".$this->getPeerClassname()."::TABLE_NAME);
	}
";

	}
} // PHP5BasicPeerBuilder

= What's new in Propel 1.5? =

== Nested Set Behavior ==

Using the `treeMode` attribute in a schema, you could turn a Propel model into a hierarchical data store starting with Propel 1.3. This method is now deprecated in favor of a new `nested_set` behavior, that does eactly the same thing, but in a more extensible and effective way.

The main difference between the two implementations is performance. On the first levels of a large tree, the Propel 1.3 implementation of Nested sets used to consume a very large amount of memory and CPU to retrieve the siblings or the children of a given node. This is no longer true with the new behavior.

This performance boost comes at a small price: you must add a new "level" column to your nested set models, and let the behavior update this column for the whole tree.

For instance, if you used nested sets to keep a list of categories, the schema used to look like:

{{{
#!xml
<table name="category" treeMode="NestedSet">
  <column name="id" primaryKey="true" autoIncrement="true" type="INTEGER"/>
  <column name="left" nestedSetLeftKey="true" type="INTEGER"/>
  <column name="right" nestedSetLeftKey="true" type="INTEGER"/>
  <column name="name" required="true" type="VARCHAR" size="10" />
</table>
}}}

The upgrade path is then pretty straightforward:

1 - Update the schema, by removing the `treeMode` and `nestedSet` attributes and adding the `nested_set` behavior and the `tree_level` column:

{{{
#!xml
<table name="category">
  <column name="id" primaryKey="true" autoIncrement="true" type="INTEGER"/>
  <column name="left" type="INTEGER"/>
  <column name="right" type="INTEGER"/>
  <column name="tree_level" type="INTEGER"/>
  <column name="name" required="true" type="VARCHAR" size="10" />
  <behavior name="nested_set">
    <parameter name="add_columns" value="false" />
    <parameter name="left_column" value="left" />
    <parameter name="right_column" value="rigt" />
    <parameter name="level_column" value="tree_level" />
  </behavior>
</table>
}}}

2 - Rebuild the model

3 - Add the level column to the database. For instance, in MySQL:

{{{
#!xml
ALTER TABLE `category` ADD COLUMN tree_level INTEGER;
}}}

4 - Update the level value in the existing nodes, using the `fixLevels()` Peer method

{{{
#!php
<?php
// run it once
CategoryPeer::fixLevels();
}}}

The nested set behavior implementation has a few added benefits:

 * All the methods that execute several queries use transactions, so a database failure won't break a tree anymore
 * The methods retrieveing a list of nodes accept a Criteria as first parameter, to filter the results
 * New methods make it easir to work with trees: `retrieveRoots()`, `isDescendantOf()`, `isAncestorOf()`, `getBranch()`, `addChild()`, etc.
 * There is no longer any introspection at runtime (for instance to check scope support), resulting in yet another boost in performance
 * A few bugs were fixed (for instance in the use of `delete()`)
 * A node can be inserted to the tree after it is saved. This allows for better preparation of data before insertion in the tree
 * The new implementation is much more robust, thanks to a ''full unit testing coverage''. That's more than 350 unit tests to ensure that your trees won't ever break due to an incorrect piece of code in the nested sets.
 * The API was rethought to make it more intuitive - but with method proxies to keep BC

As a consequence, the use of `treeMode="NestedSet"` in a schema is deprecated. Check the new [nested_set behavior documentation] for more details.

== Code Cleanup ==

=== Directory Structure Changes ===

The organization of the Propel runtime and generator code has been reworked, in order to make navigation across Propel classes easier for developers. End users should see no difference, apart if your `build.properties` references alternate builder classes in the Propel code. In that case, you will need to update your `build.properties` with the new paths. For instance, a reference to:

{{{
#!ini
propel.builder.peer.class = propel.engine.builder.om.php5.PHP5PeerBuilder
}}}

Must be changed to:

{{{
#!ini
propel.builder.peer.class = builder.om.PHP5PeerBuilder  
}}}

Browse the Propel generator directory structure to find the classes you need.

=== DebugPDO Refactoring ===

To allow custom connection handlers, the debug code that was written in the `DebugPDO` class has been moved to `PropelPDO`. The change is completely backwards compatible, but makes it easier to connect to a database without using PDO.

During the change, the documentation about Propel logging and debugging features was rewritten and should now be clearer.

=== Other Minor Code Cleanups ===

 * Removed references to Creole in the code (Propel uses PDO instead of Creole since version 1.3)

== Criteria Enhancements ==

`Criteria::addOr()` operates the way you always expected it to. For instance, in Propel 1.4, `addOr()` resulted in a SQL `AND` if called on a column with no other condition:

{{{
#!php
<?php
// addOr() used to work on a column with an existing condition
$c = new Criteria();
$c->add(BookPeer::TITLE, '%Leo%', Criteria::LIKE);
$c->addOr(BookPeer::TITLE, '%Tolstoi%', Criteria::LIKE);
// translates in SQL as
// WHERE (book.TITLE LIKE '%Leo%' OR book.TITLE LIKE '%Tolstoi%')

// addOr() used to fail on a column with no existing condition
$c = new Criteria();
$c->add(BookPeer::TITLE, '%Leo%', Criteria::LIKE);
$c->addOr(BookPeer::ISBN, '1234', Criteria::EQUAL);
// translates in SQL as
// WHERE book.TITLE LIKE '%Leo%' AND book.ISBN = '1234'
}}}

This is fixed in Propel 1.5. This means that you don't need to call upon the `Criterion` object for a simple OR clause:

{{{
#!php
<?php
// addOr() now works on a column with no existing condition
$c = new Criteria();
$c->add(BookPeer::TITLE, '%Leo%', Criteria::LIKE);
$c->addOr(BookPeer::ISBN, '1234', Criteria::EQUAL);
// translates in SQL as
// WHERE (book.TITLE LIKE '%Leo%' OR book.ISBN = '1234')

// and it's much faster to write than
$c = new Criteria();
$c1 = $c->getNewCriterion(BookPeer::TITLE, '%Leo%', Criteria::LIKE);
$c2 = $c->getNewCriterion(BookPeer::ISBN, '1234', Criteria::EQUAL);
$c1->addOr($c2);
$c->add($c1);
}}}

`add()` and `addOr()` only allow simple logical operations on a single condition. For more complex logic,  Propel 1.4 forced you to use Criterions again. This is no longer the case in Propel 1.5, which provides a new `Criteria::combine()` method. It expects an array of ''named conditions'' to be combined, and an operator. Use the fourth argument of `add()` to name a condition:

{{{
#!php
<?php
$c = new Criteria();
$c->add(BookPeer::TITLE, 'Foo', Criteria::EQUAL, 'cond1');     // creates a condition named 'cond1'
$c->add(BookPeer::TITLE, 'Bar', Criteria::EQUAL, 'cond2');     // creates a condition named 'cond2'
$c->combine(array('cond1', 'cond2'), Criteria::LOGICAL_OR);    // combine 'cond1' and 'cond2' with a logical OR
// translates in SQL as
// WHERE (book.TITLE = 'foo' OR book.TITLE = 'bar');
}}}
 
`combine()` accepts more than two conditions at a time:
{{{
#!php
<?php
$c = new Criteria();
$c->add(BookPeer::TITLE, 'Foo', Criteria::EQUAL, 'cond1');
$c->add(BookPeer::TITLE, 'Bar', Criteria::EQUAL, 'cond2');
$c->add(BookPeer::TITLE, 'FooBar', Criteria::EQUAL, 'cond3');
$c->combine(array('cond1', 'cond2', 'cond3'), Criteria::LOGICAL_OR);
// translates in SQL as
// WHERE ((book.TITLE = 'foo' OR book.TITLE = 'bar') OR book.TITLE = 'FooBar');
}}}

`combine()` itself can return a named condition to be combined later. So it allows for any level of logical complexity:

{{{
#!php
<?php
$c = new Criteria();

$c->add(BookPeer::TITLE, 'Foo', Criteria::EQUAL, 'cond1');
$c->add(BookPeer::TITLE, 'Bar', Criteria::EQUAL, 'cond2');
$c->combine(array('cond1', 'cond2'), Criteria::LOGICAL_OR, 'cond12');

$c->add(BookPeer::ISBN, '1234', Criteria::EQUAL, 'cond3');
$c->add(BookPeer::ISBN, '4567', Criteria::EQUAL, 'cond4');
$c->combine(array('cond3', 'cond4'), Criteria::LOGICAL_OR, 'cond34');

$c->combine(array('cond12', 'cond34'), Criteria::LOGICAL_AND);

// WHERE (book.TITLE = 'foo' OR book.TITLE = 'bar') 
//   AND (book.ISBN = '1234' OR book.ISBN = '4567');
}}}

The new `combine()` method makes it much easier to handle logically complex criterions. The good news is that if your application code already uses the old Criterion way, it will continue to work with Propel 1.5 as all these changes are backwards compatible.
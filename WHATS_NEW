= What's new in Propel 1.4? =

== Joins with multiple conditions ==

You can now create joins with any number of conditions and any comparator using the new `Criteria::addMultipleJoin()` method.

{{{
#!php
<?php
$c = new Criteria();
$c->addMultipleJoin(array(
    array(ReaderFavoritePeer::BOOK_ID, BookOpinionPeer::BOOK_ID),
    array(ReaderFavoritePeer::READER_ID, BookOpinionPeer::READER_ID))
  Criteria::INNER_JOIN);
}}}
{{{
#!sql
// SQL result
SELECT ...
FROM reader_favorite 
INNER JOIN book_opinion ON (reader_favorite.BOOK_ID = book_opinion.BOOK_ID 
                        AND reader_favorite.READER_ID = book_opinion.READER_ID)
}}}

You can add a third operator to each join condition to allow complex joins:

{{{
#!php
<?php
$c = new Criteria();
$c->addMultipleJoin(array(
    array(Book::USER_ID, UserPeer::ID))
    array(UserPeer::RANK, 12, Criteria::GREATER_THAN),
  Criteria::LEFT_JOIN);
}}}
{{{
#!sql
// SQL result
SELECT ...
FROM book
LEFT JOIN user ON (book.USER_ID = user.ID AND user.RANK > 12)
}}}

Note that the former way to define a composite join using arrays as arguments of `addJoin()` is deprecated.

== Better Introspection at Runtime ==

A few methods were added to the Map classes to ease runtime introspection:
{{{
TableMap  DatabaseMap::getTableByPhpName($name) // TableMap object by object model name, e.g. 'Book'
ColumnMap DatabaseMap::getColumn($name) // ColumnMap object by fully qualified name, e.g. book.AUTHOR_ID
TableMap  ColumnMap::getRelatedTable()  // Related TableMap object by foreign key
ColumnMap ColumnMap::getRelatedColumn() // Related ColumnMap object by foreign key
Array     TableMap::getPrimaryKeys()    // List of the ColumnMap objects corresponding to the table primary keys
Array     TableMap::getForeignKeys()    // List of the ColumnMap objects corresponding to the table foreign keys
Arrat     TableMap::getRelations()      // List of the table relationships, as RelationMap objects
String    TableMap::getPackage()        // Package of the table
}}}

Also, it is now much easier to get the name of the Propel object class from the Peer class:
{{{
echo BookPeer::getOMClass()                    => 'bookstore.Book'
echo BookPeer::getOMClass($withPrefix = false) => 'Book'
}}}

== MapBuilders are gone ==

Runtime introspection used to rely on runtime builder classes for TableMap objects, called MapBuilders. These classes are not generated anymore by Propel. Instead, Propel generates TableMap classes that are easier to deal with. 

The standard way to get a TableMap through the Peer classes works just the same as before:

{{{
#!php
<?php
$bookTableMap = BookPeer::getTableMap();
}}}

But building TableMaps by hand is a lot easier:

{{{
#!php
<?php
// Propel 1.3 way to initialize a TableMap
$className = 'Book';
$mapBuilderClass = $className . 'MapBuilder';
$mapBuilder = new $mapBuilderClass();
if (!$mapBuilder->isBuilt())
{
  $mapBuilder->doBuild();
}
$bookTableMap = $databaseMap->getTable('book');

// Propel 1.4 way to initialize a TableMap
$className = 'Book';
$tableMapClass = $className . 'TableMap';
$bookTableMap = $databaseMap->addTableFromMapClass($tableMapClass);
}}}

Note that if you want to make sure that all the tables related to a given table have their TableMaps loaded, you just need to ask for the table relations:

{{{
#!php
<?php
// build all the TableMap objects of tables related to Book
$relations = $bookTableMap->getRelations();
}}}

== `BasePeer::populateStmtValues()` is now public ==

You can now use a SQL query of your own, or modify the one returned by `BasePeer::createSelectSql()`, and use the binding capabilities of Propel to populate a query with a set of values. Propel uses the PDO type of the column to do the binding, so this method may save you some hassle: 

{{{
$sql = BasePeer::createSelectSql($criteria, $params);
$sql = "INSERT INTO temp_table_name $sql";
$stmt = $con->prepare($sql);
BasePeer::populateStmtValues($stmt, $params, $dbMap, $db);
$stmt->execute();
}}}
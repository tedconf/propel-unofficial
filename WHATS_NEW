= What's new in Propel 1.6? =

[[PageOutline]]

Propel 1.6 is a new backwards compatible iteration of the Propel 1.x branch. As usual, don't forget to rebuild your model once you upgrade to this new version.

== Migrations ==

How do you manage changes to your database as the Model evolves and the schema changes? Calling the `sql` and `insert-sql` task each time the schema is updated has one dreadful drawback: it erases all the data in the database.

Starting with Propel 1.6, the `sql`-`insert-sql` sequence is replaced by the `diff`-`migrate` sequence:

{{{
> propel-gen diff

[propel-sql-diff] Reading databases structure...
[propel-sql-diff] 1 tables imported from databases.
[propel-sql-diff] Loading XML schema files...
[propel-sql-diff] 2 tables found in 1 schema file.
[propel-sql-diff] Comparing models...
[propel-sql-diff] Structure of database was modified: 1 added table, 1 modified table
[propel-sql-diff] "PropelMigration_1286484196.php" file successfully created in /path/to/project/build/migrations
[propel-sql-diff]   Please review the generated SQL statements, and add data migration code if necessary.
[propel-sql-diff]   Once the migration class is valid, call the "migrate" task to execute it.

> propel-gen migrate

[propel-migration] Executing migration PropelMigration_1286484196 up
[propel-migration] 4 of 4 SQL statements executed successfully on datasource "bookstore"
[propel-migration] Migration complete. No further migration to execute.
}}}

`diff` compares the schema to the database, and generates a class with all the required `ALTER TABLE` and `CREATE TABLE` statements to update the database structure. This migration class then feeds the `migrate` task, which connects to the database and executes the migrations - with no data loss.

Migrations are a fantastic way to work on complex projects with always evolving models ; they are also a great tool for team work, since migration classes can be shared among all developers. That way, when a developer adds a table to the model, a second developer just needs to run the related migration to have the table added to the table.

Propel migrations can also be executed incrementally - the new `up` and `down` tasks are there for that. And when you're lost in migration, call the `status` task to chack which migrations were already executed, and which ones should be executed to update the database structure.

The Propel guide offers [wiki:Users/Documentation/1.6/Migrations an entire chapter on Migrations] to explain how to use them and how they work.

Migrations only work on MySQL for now. On other platforms, you should continue to use `sql` and `insert-sql`.

== XML/YAML/JSON/CSV Parsing and Dumping ==

ActiveRecord and Collection objects now have the ability to be converted to and from a string, using any of the XML, YAML, JSON, and CSV formats.

The syntax is very intuitive: ActiveRecord and collection objects now offer a `toXML()` and a `fromXML()` method (same for YAML, JSON, and CSV). Here are a few examples:

{{{
#!php
<?php
// dump a collection to YAML
$books = BookQuery::create()
  ->orderByTitle()
  ->joinWith('Author')
  ->find();
echo $books->toYAML();
// Book_1:
//   Id: 123
//   Title: Pride and Prejudice
//   AuthorId: 456
//   Author:
//     Id: 456
//     FirstName: Jane
//     LastName: Austen
// Book_2:
//   Id: 789
//   Title: War and Peace
//   AuthorId: 147
//   Author:
//     Id: 147
//     FirstName: Leo
//     LastName: Tolstoi

// parse an XML string into an object
$bookString = <<<EOF
<?xml version="1.0" encoding="UTF-8"?>
<data>
  <Id>9012</Id>
  <Title><![CDATA[Don Juan]]></Title>
  <ISBN><![CDATA[0140422161]]></ISBN>
  <Price>12.99</Price>
  <PublisherId>1234</PublisherId>
  <AuthorId>5678</AuthorId>
</data>
EOF;
$book = new Book();
$book->fromXML($bookString);
echo $book->getTitle(); // Don Juan
}}}

== Model Objects String Representation ==

Taking advantage of the dumping abilities just introduced, all ActiveRecord objects now have a string representation based on a YAML dump of their properties:

{{{
#!php
<?php
$author = new Author();
$author->setFirstName('Leo');
$author->setLastName('Tolstoi');
echo $author;
// Id: null
// FirstName: Leo
// LastName: Tolstoi
// Email: null
// Age: null
}}}

'''Tip''': Tables with a column using the `isPrimaryString` attribute still output the value of a single column as string representation.

`PropelCollection` objects also take advantage from this possibility:

{{{
#!php
<?php
$authors = AuthorQuery::create()
  ->orderByLastName()
  ->find();
echo $authors;
// Author_0:
//   Id: 456
//   FirstName: Jane
//   LastName: Austen
//   Email: null
//   Age: null
// Author_1:
//   Id: 147
//   FirstName: Leo
//   LastName: Tolstoi
//   Email: null
//   Age: null
}}}

If you want to use another format for the default string representation instead of YAML, you can set the `defaultStringFormat` attribute to any of the supported formats in either the `<database>` or the `<table>` elements in the XML schema:
	
{{{
#!php
<table name="publisher" defaultStringFormat="XML">
	<column name="id" required="true" primaryKey="true" autoIncrement="true" type="INTEGER" />
	<column name="name" required="true" type="VARCHAR" size="128" />
</table>
}}}

{{{
#!php
<?php
$publisher = new Publisher();
$publisher->setName('Penguin');
echo $publisher;
//<?xml version="1.0" encoding="UTF-8"?>
//<data>
//  <Id></Id>
//  <Name><![CDATA[Peguin]]></Name>
//</data>
}}}

== Multiple Buildtime Connections ==

Propel 1.5 used the `build.properties` for buildtime connection settings. This had one major drawback: it used to be impossible to deal with several connections at buildtime, let alone several RDBMS.

In Propel 1.6, you can write your buildtime connection settings in a `buildtime-conf.xml` file. The format is the same as the `runtime-conf.xml` file, so a good starting point is to copy the runtime conf, and change the settings for users wit hgreater privileges.

Here is an example buildtime configuration file that defines a MySQL and a SQLite connection:

{{{
#!xml
<?xml version="1.0"?>
<config>
  <propel>
    <datasources default="bookstore">
      <datasource id="bookstore">
        <adapter>mysql</adapter>
        <connection>
          <dsn>mysql:host=localhost;dbname=bookstore</dsn>
          <user>testuser</user>
          <password>password</password>
        </connection>
      </datasource>
      <datasource id="cms">
        <adapter>sqlite</adapter>
        <connection>
          <dsn>sqlite:/opt/databases/mydb.sq3</dsn>
        </connection>
      </datasource>
    </datasources>
  </propel>
</config>
}}}

Now that Propel can deal with database vendors at buildtime more accurately, the generated classes offer more optimizations for the database they rely one. Incidentally, that means that you should rebuild your model if you use different database vendors. Thats includes cases when your developement and production environments use different vendors.

== Foreign Key Filters Now Accept a Collection ==

The generated `filterByRelationName()` methods in the model queries now accept a `PropelCollection` as argument. This will allow you to keep using objects and avoid dealing with foreign keys completely:

{{{
#!php
<?php
// get young authors
$authors = AuthorQuery::create()
  ->filterByAge(array('max' => 35))
  ->find(); // $authors is a PropelObjectCollection
// get all books by young authors
$books = BookQuery::create()
  ->filterByAuthor($authors) // <= That's new
  ->find();
}}}
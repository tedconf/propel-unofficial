= What's new in Propel 1.4? =

== Behaviors ==

You can now package and reuse behaviors across your models. For instance, keeping the date of creation of an object and the date of latest update is as simple as declaring the `timestampable` behavior in the table declaration:

{{{
<table name="book">
  <column name="id" required="true" primaryKey="true" autoIncrement="true" type="INTEGER" />
  <column name="title" type="VARCHAR" required="true" />
  <behavior name="timestampable" />
</table>
}}}

Rebuild your model, and you now have two new columns in the `book` table automatically set to the creation and update dates:

{{{
#!php
<?php
$b = new Book();
$b->setTitle('War And Peace');
$b->save();
echo $b->getCreatedAt(); // 2009-10-02 18:14:23
echo $b->getUpdatedAt(); // 2009-10-02 18:14:23
$b->setTitle('Anna Karenina');
$b->save();
echo $b->getCreatedAt(); // 2009-10-02 18:14:23
echo $b->getUpdatedAt(); // 2009-10-02 18:14:25
}}}

This new feature is so powerful that it requires a documentation on its own. Read it in the [wiki:Users/Documentation/1.4#HowTos HowTos] section.

== Joins with multiple conditions ==

You can now create joins with any number of conditions and any comparator using the new `Criteria::addMultipleJoin()` method.

{{{
#!php
<?php
$c = new Criteria();
$c->addMultipleJoin(array(
    array(ReaderFavoritePeer::BOOK_ID, BookOpinionPeer::BOOK_ID),
    array(ReaderFavoritePeer::READER_ID, BookOpinionPeer::READER_ID))
  Criteria::INNER_JOIN);
}}}
{{{
#!sql
// SQL result
SELECT ...
FROM reader_favorite 
INNER JOIN book_opinion ON (reader_favorite.BOOK_ID = book_opinion.BOOK_ID 
                        AND reader_favorite.READER_ID = book_opinion.READER_ID)
}}}

You can add a third operator to each join condition to allow complex joins:

{{{
#!php
<?php
$c = new Criteria();
$c->addMultipleJoin(array(
    array(Book::USER_ID, UserPeer::ID))
    array(UserPeer::RANK, 12, Criteria::GREATER_THAN),
  Criteria::LEFT_JOIN);
}}}
{{{
#!sql
// SQL result
SELECT ...
FROM book
LEFT JOIN user ON (book.USER_ID = user.ID AND user.RANK > 12)
}}}

Note that the former way to define a composite join using arrays as arguments of `addJoin()` is deprecated.

== Generated `__toString()` in Base Object ==

Propel can generate a `__toString()` method for your Model objects if you define a column as `primaryString` in the schema:

{{{
// in the schema
<table name="book" phpName="Book">
  ..
  <column name="title" type="varchar" size="125" primaryString="true" />
  ..
</table>
}}}   

After a model build, the generated `BaseBook` class offers the following magic method:

{{{
#!php
<?php
public function __toString()
{
  return (string) $this->getTitle();
}
}}}

That means that the default string representation of `Book` objects is the value of the `title` column:

{{{
#!php
<?php
$book = new book();
$book->setTitle('War And Peace');
echo $book; // 'War And Peace'
}}}

== New Peer constant: OM_CLASS ==

Did you ever try to get the Propel Model class related to a Peer class? If you did, you probably noticed that the only available constant providing this information also contained package information:

{{{
#!php
<?php
// in BaseBookPeer.php
/** A class that can be returned by this peer. */
const CLASS_DEFAULT = 'bookstore.Book';
}}}

This can be useful if you don't use autoloading; but if you do, retrieving the actual Propel model class name involved some string operations to remove the package information. This is no more necessary in Propel 1.4, since the Peer classes offer a new constant:

{{{
#!php
<?php
// in BaseBookPeer.php
/** the related Propel class for this table */
const OM_CLASS = 'Book';
}}}

The generated Peer methods now use this constant and avoid string operations. Therefore, they should be slightly faster.

== PropelPager Implements Countable and Iterator Interfaces ==

Did you know Propel offered a pagination utility class? It just got better, by now supporting the `Countable` and `Iterator` interfaces. That means that you can manipulate a `PropelPager` object as if it was an array:

{{{
#!php
<?php
$c = new Criteria();
$c->add(BookPeer::AUTHOR, $authorId);
$pager = new PropelPager($c, 'BookPeer', 'doSelect', $page = 1, $rowsPerPage = 20);

if(count($pager)) // if the current page has results
{
  foreach($pager as $book) // get pager results and iterate on them
  {
    echo $book->getTitle();
  }
}
}}}

Note that the `PropelPager` utility has a brand new documentation in the [wiki:Users/Documentation/1.4#HowTos HowTos] section. 

== Better Introspection at Runtime ==

A few methods were added to the Map classes to ease runtime introspection:
{{{
TableMap  DatabaseMap::getTableByPhpName($name) // TableMap object by object model name, e.g. 'Book'
ColumnMap DatabaseMap::getColumn($name) // ColumnMap object by fully qualified name, e.g. book.AUTHOR_ID
TableMap  ColumnMap::getRelatedTable()  // Related TableMap object by foreign key
ColumnMap ColumnMap::getRelatedColumn() // Related ColumnMap object by foreign key
Array     TableMap::getPrimaryKeys()    // List of the ColumnMap objects corresponding to the table primary keys
Array     TableMap::getForeignKeys()    // List of the ColumnMap objects corresponding to the table foreign keys
Arrat     TableMap::getRelations()      // List of the table relationships, as RelationMap objects
String    TableMap::getPackage()        // Package of the table
}}}

Also, it is now much easier to get the name of the Propel object class from the Peer class:
{{{
echo BookPeer::getOMClass()                    => 'bookstore.Book'
echo BookPeer::getOMClass($withPrefix = false) => 'Book'
}}}

== MapBuilders are gone ==

Runtime introspection used to rely on runtime builder classes for TableMap objects, called MapBuilders. These classes are not generated anymore by Propel. Instead, Propel generates TableMap classes that are easier to deal with. 

The standard way to get a TableMap through the Peer classes works just the same as before:

{{{
#!php
<?php
$bookTableMap = BookPeer::getTableMap();
}}}

But building TableMaps by hand is a lot easier:

{{{
#!php
<?php
// Propel 1.3 way to initialize a TableMap
$className = 'Book';
$mapBuilderClass = $className . 'MapBuilder';
$mapBuilder = new $mapBuilderClass();
if (!$mapBuilder->isBuilt())
{
  $mapBuilder->doBuild();
}
$bookTableMap = $databaseMap->getTable('book');

// Propel 1.4 way to initialize a TableMap
$className = 'Book';
$tableMapClass = $className . 'TableMap';
$bookTableMap = $databaseMap->addTableFromMapClass($tableMapClass);
}}}

Note that if you want to make sure that all the tables related to a given table have their TableMaps loaded, you just need to ask for the table relations:

{{{
#!php
<?php
// build all the TableMap objects of tables related to Book
$relations = $bookTableMap->getRelations();
}}}

== `BasePeer::populateStmtValues()` is now public ==

You can now use a SQL query of your own, or modify the one returned by `BasePeer::createSelectSql()`, and use the binding capabilities of Propel to populate a query with a set of values. Propel uses the PDO type of the column to do the binding, so this method may save you some hassle: 

{{{
#!php
<?php
$sql = BasePeer::createSelectSql($criteria, $params);
$sql = "INSERT INTO temp_table_name $sql";
$stmt = $con->prepare($sql);
BasePeer::populateStmtValues($stmt, $params, $dbMap, $db);
$stmt->execute();
}}}